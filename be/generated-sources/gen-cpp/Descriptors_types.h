/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Descriptors_TYPES_H
#define Descriptors_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "CatalogObjects_types.h"
#include "Types_types.h"
#include "Exprs_types.h"


namespace impala {


class TSlotDescriptor {
 public:

  static const char* ascii_fingerprint; // = "13BD264E8D3EE03EE2E4399689387CCB";
  static const uint8_t binary_fingerprint[16]; // = {0x13,0xBD,0x26,0x4E,0x8D,0x3E,0xE0,0x3E,0xE2,0xE4,0x39,0x96,0x89,0x38,0x7C,0xCB};

  TSlotDescriptor() : id(0), parent(0), columnPos(0), byteOffset(0), nullIndicatorByte(0), nullIndicatorBit(0), slotIdx(0), isMaterialized(0) {
  }

  virtual ~TSlotDescriptor() throw() {}

   ::impala::TSlotId id;
   ::impala::TTupleId parent;
   ::impala::TColumnType slotType;
  int32_t columnPos;
  int32_t byteOffset;
  int32_t nullIndicatorByte;
  int32_t nullIndicatorBit;
  int32_t slotIdx;
  bool isMaterialized;

  void __set_id(const  ::impala::TSlotId val) {
    id = val;
  }

  void __set_parent(const  ::impala::TTupleId val) {
    parent = val;
  }

  void __set_slotType(const  ::impala::TColumnType& val) {
    slotType = val;
  }

  void __set_columnPos(const int32_t val) {
    columnPos = val;
  }

  void __set_byteOffset(const int32_t val) {
    byteOffset = val;
  }

  void __set_nullIndicatorByte(const int32_t val) {
    nullIndicatorByte = val;
  }

  void __set_nullIndicatorBit(const int32_t val) {
    nullIndicatorBit = val;
  }

  void __set_slotIdx(const int32_t val) {
    slotIdx = val;
  }

  void __set_isMaterialized(const bool val) {
    isMaterialized = val;
  }

  bool operator == (const TSlotDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(parent == rhs.parent))
      return false;
    if (!(slotType == rhs.slotType))
      return false;
    if (!(columnPos == rhs.columnPos))
      return false;
    if (!(byteOffset == rhs.byteOffset))
      return false;
    if (!(nullIndicatorByte == rhs.nullIndicatorByte))
      return false;
    if (!(nullIndicatorBit == rhs.nullIndicatorBit))
      return false;
    if (!(slotIdx == rhs.slotIdx))
      return false;
    if (!(isMaterialized == rhs.isMaterialized))
      return false;
    return true;
  }
  bool operator != (const TSlotDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSlotDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSlotDescriptor &a, TSlotDescriptor &b);

typedef struct _TTableDescriptor__isset {
  _TTableDescriptor__isset() : colNames(false), hdfsTable(false), hbaseTable(false), dataSourceTable(false) {}
  bool colNames;
  bool hdfsTable;
  bool hbaseTable;
  bool dataSourceTable;
} _TTableDescriptor__isset;

class TTableDescriptor {
 public:

  static const char* ascii_fingerprint; // = "BB1C2BD425968E38B428B200B15475AE";
  static const uint8_t binary_fingerprint[16]; // = {0xBB,0x1C,0x2B,0xD4,0x25,0x96,0x8E,0x38,0xB4,0x28,0xB2,0x00,0xB1,0x54,0x75,0xAE};

  TTableDescriptor() : id(0), tableType(( ::impala::TTableType::type)0), numCols(0), numClusteringCols(0), tableName(), dbName() {
  }

  virtual ~TTableDescriptor() throw() {}

   ::impala::TTableId id;
   ::impala::TTableType::type tableType;
  int32_t numCols;
  int32_t numClusteringCols;
  std::vector<std::string>  colNames;
   ::impala::THdfsTable hdfsTable;
   ::impala::THBaseTable hbaseTable;
   ::impala::TDataSourceTable dataSourceTable;
  std::string tableName;
  std::string dbName;

  _TTableDescriptor__isset __isset;

  void __set_id(const  ::impala::TTableId val) {
    id = val;
  }

  void __set_tableType(const  ::impala::TTableType::type val) {
    tableType = val;
  }

  void __set_numCols(const int32_t val) {
    numCols = val;
  }

  void __set_numClusteringCols(const int32_t val) {
    numClusteringCols = val;
  }

  void __set_colNames(const std::vector<std::string> & val) {
    colNames = val;
    __isset.colNames = true;
  }

  void __set_hdfsTable(const  ::impala::THdfsTable& val) {
    hdfsTable = val;
    __isset.hdfsTable = true;
  }

  void __set_hbaseTable(const  ::impala::THBaseTable& val) {
    hbaseTable = val;
    __isset.hbaseTable = true;
  }

  void __set_dataSourceTable(const  ::impala::TDataSourceTable& val) {
    dataSourceTable = val;
    __isset.dataSourceTable = true;
  }

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_dbName(const std::string& val) {
    dbName = val;
  }

  bool operator == (const TTableDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(tableType == rhs.tableType))
      return false;
    if (!(numCols == rhs.numCols))
      return false;
    if (!(numClusteringCols == rhs.numClusteringCols))
      return false;
    if (__isset.colNames != rhs.__isset.colNames)
      return false;
    else if (__isset.colNames && !(colNames == rhs.colNames))
      return false;
    if (__isset.hdfsTable != rhs.__isset.hdfsTable)
      return false;
    else if (__isset.hdfsTable && !(hdfsTable == rhs.hdfsTable))
      return false;
    if (__isset.hbaseTable != rhs.__isset.hbaseTable)
      return false;
    else if (__isset.hbaseTable && !(hbaseTable == rhs.hbaseTable))
      return false;
    if (__isset.dataSourceTable != rhs.__isset.dataSourceTable)
      return false;
    else if (__isset.dataSourceTable && !(dataSourceTable == rhs.dataSourceTable))
      return false;
    if (!(tableName == rhs.tableName))
      return false;
    if (!(dbName == rhs.dbName))
      return false;
    return true;
  }
  bool operator != (const TTableDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableDescriptor &a, TTableDescriptor &b);

typedef struct _TTupleDescriptor__isset {
  _TTupleDescriptor__isset() : tableId(false) {}
  bool tableId;
} _TTupleDescriptor__isset;

class TTupleDescriptor {
 public:

  static const char* ascii_fingerprint; // = "10850C26C1AD0C180808B8FC6F756B91";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x85,0x0C,0x26,0xC1,0xAD,0x0C,0x18,0x08,0x08,0xB8,0xFC,0x6F,0x75,0x6B,0x91};

  TTupleDescriptor() : id(0), byteSize(0), numNullBytes(0), tableId(0) {
  }

  virtual ~TTupleDescriptor() throw() {}

   ::impala::TTupleId id;
  int32_t byteSize;
  int32_t numNullBytes;
   ::impala::TTableId tableId;

  _TTupleDescriptor__isset __isset;

  void __set_id(const  ::impala::TTupleId val) {
    id = val;
  }

  void __set_byteSize(const int32_t val) {
    byteSize = val;
  }

  void __set_numNullBytes(const int32_t val) {
    numNullBytes = val;
  }

  void __set_tableId(const  ::impala::TTableId val) {
    tableId = val;
    __isset.tableId = true;
  }

  bool operator == (const TTupleDescriptor & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(byteSize == rhs.byteSize))
      return false;
    if (!(numNullBytes == rhs.numNullBytes))
      return false;
    if (__isset.tableId != rhs.__isset.tableId)
      return false;
    else if (__isset.tableId && !(tableId == rhs.tableId))
      return false;
    return true;
  }
  bool operator != (const TTupleDescriptor &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTupleDescriptor & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTupleDescriptor &a, TTupleDescriptor &b);

typedef struct _TDescriptorTable__isset {
  _TDescriptorTable__isset() : slotDescriptors(false), tableDescriptors(false) {}
  bool slotDescriptors;
  bool tableDescriptors;
} _TDescriptorTable__isset;

class TDescriptorTable {
 public:

  static const char* ascii_fingerprint; // = "00562A6F347FA4374A672FDAC7CD04A4";
  static const uint8_t binary_fingerprint[16]; // = {0x00,0x56,0x2A,0x6F,0x34,0x7F,0xA4,0x37,0x4A,0x67,0x2F,0xDA,0xC7,0xCD,0x04,0xA4};

  TDescriptorTable() {
  }

  virtual ~TDescriptorTable() throw() {}

  std::vector<TSlotDescriptor>  slotDescriptors;
  std::vector<TTupleDescriptor>  tupleDescriptors;
  std::vector<TTableDescriptor>  tableDescriptors;

  _TDescriptorTable__isset __isset;

  void __set_slotDescriptors(const std::vector<TSlotDescriptor> & val) {
    slotDescriptors = val;
    __isset.slotDescriptors = true;
  }

  void __set_tupleDescriptors(const std::vector<TTupleDescriptor> & val) {
    tupleDescriptors = val;
  }

  void __set_tableDescriptors(const std::vector<TTableDescriptor> & val) {
    tableDescriptors = val;
    __isset.tableDescriptors = true;
  }

  bool operator == (const TDescriptorTable & rhs) const
  {
    if (__isset.slotDescriptors != rhs.__isset.slotDescriptors)
      return false;
    else if (__isset.slotDescriptors && !(slotDescriptors == rhs.slotDescriptors))
      return false;
    if (!(tupleDescriptors == rhs.tupleDescriptors))
      return false;
    if (__isset.tableDescriptors != rhs.__isset.tableDescriptors)
      return false;
    else if (__isset.tableDescriptors && !(tableDescriptors == rhs.tableDescriptors))
      return false;
    return true;
  }
  bool operator != (const TDescriptorTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescriptorTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDescriptorTable &a, TDescriptorTable &b);

} // namespace

#endif
