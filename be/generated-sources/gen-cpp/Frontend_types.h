/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Frontend_TYPES_H
#define Frontend_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Types_types.h"
#include "ImpalaInternalService_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "Descriptors_types.h"
#include "Data_types.h"
#include "Exprs_types.h"
#include "cli_service_types.h"
#include "Status_types.h"
#include "CatalogObjects_types.h"
#include "CatalogService_types.h"


namespace impala {

struct TDescribeTableOutputStyle {
  enum type {
    MINIMAL = 0,
    FORMATTED = 1
  };
};

extern const std::map<int, const char*> _TDescribeTableOutputStyle_VALUES_TO_NAMES;

struct TCatalogOpType {
  enum type {
    SHOW_TABLES = 0,
    SHOW_DBS = 1,
    SHOW_STATS = 2,
    USE = 3,
    DESCRIBE = 4,
    SHOW_FUNCTIONS = 5,
    RESET_METADATA = 6,
    DDL = 7,
    SHOW_CREATE_TABLE = 8,
    SHOW_DATA_SRCS = 9
  };
};

extern const std::map<int, const char*> _TCatalogOpType_VALUES_TO_NAMES;

struct TMetadataOpcode {
  enum type {
    GET_TYPE_INFO = 0,
    GET_CATALOGS = 1,
    GET_SCHEMAS = 2,
    GET_TABLES = 3,
    GET_TABLE_TYPES = 4,
    GET_COLUMNS = 5,
    GET_FUNCTIONS = 6
  };
};

extern const std::map<int, const char*> _TMetadataOpcode_VALUES_TO_NAMES;

struct TSymbolType {
  enum type {
    UDF_EVALUATE = 0,
    UDF_PREPARE = 1,
    UDF_CLOSE = 2
  };
};

extern const std::map<int, const char*> _TSymbolType_VALUES_TO_NAMES;

struct TSymbolLookupResultCode {
  enum type {
    SYMBOL_FOUND = 0,
    BINARY_NOT_FOUND = 1,
    SYMBOL_NOT_FOUND = 2
  };
};

extern const std::map<int, const char*> _TSymbolLookupResultCode_VALUES_TO_NAMES;


class THiveUdfExecutorCtorParams {
 public:

  static const char* ascii_fingerprint; // = "BFEAE852B4DE1D741753368508D2DB37";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0xEA,0xE8,0x52,0xB4,0xDE,0x1D,0x74,0x17,0x53,0x36,0x85,0x08,0xD2,0xDB,0x37};

  THiveUdfExecutorCtorParams() : local_location(), input_nulls_ptr(0), input_buffer_ptr(0), output_null_ptr(0), output_buffer_ptr(0) {
  }

  virtual ~THiveUdfExecutorCtorParams() throw() {}

   ::impala::TFunction fn;
  std::string local_location;
  std::vector<int32_t>  input_byte_offsets;
  int64_t input_nulls_ptr;
  int64_t input_buffer_ptr;
  int64_t output_null_ptr;
  int64_t output_buffer_ptr;

  void __set_fn(const  ::impala::TFunction& val) {
    fn = val;
  }

  void __set_local_location(const std::string& val) {
    local_location = val;
  }

  void __set_input_byte_offsets(const std::vector<int32_t> & val) {
    input_byte_offsets = val;
  }

  void __set_input_nulls_ptr(const int64_t val) {
    input_nulls_ptr = val;
  }

  void __set_input_buffer_ptr(const int64_t val) {
    input_buffer_ptr = val;
  }

  void __set_output_null_ptr(const int64_t val) {
    output_null_ptr = val;
  }

  void __set_output_buffer_ptr(const int64_t val) {
    output_buffer_ptr = val;
  }

  bool operator == (const THiveUdfExecutorCtorParams & rhs) const
  {
    if (!(fn == rhs.fn))
      return false;
    if (!(local_location == rhs.local_location))
      return false;
    if (!(input_byte_offsets == rhs.input_byte_offsets))
      return false;
    if (!(input_nulls_ptr == rhs.input_nulls_ptr))
      return false;
    if (!(input_buffer_ptr == rhs.input_buffer_ptr))
      return false;
    if (!(output_null_ptr == rhs.output_null_ptr))
      return false;
    if (!(output_buffer_ptr == rhs.output_buffer_ptr))
      return false;
    return true;
  }
  bool operator != (const THiveUdfExecutorCtorParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THiveUdfExecutorCtorParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THiveUdfExecutorCtorParams &a, THiveUdfExecutorCtorParams &b);

typedef struct _TGetTablesParams__isset {
  _TGetTablesParams__isset() : db(false), pattern(false), session(false) {}
  bool db;
  bool pattern;
  bool session;
} _TGetTablesParams__isset;

class TGetTablesParams {
 public:

  static const char* ascii_fingerprint; // = "1030EF7897B4F6687B63BE655FCE0522";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x30,0xEF,0x78,0x97,0xB4,0xF6,0x68,0x7B,0x63,0xBE,0x65,0x5F,0xCE,0x05,0x22};

  TGetTablesParams() : db(), pattern() {
  }

  virtual ~TGetTablesParams() throw() {}

  std::string db;
  std::string pattern;
   ::impala::TSessionState session;

  _TGetTablesParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_pattern(const std::string& val) {
    pattern = val;
    __isset.pattern = true;
  }

  void __set_session(const  ::impala::TSessionState& val) {
    session = val;
    __isset.session = true;
  }

  bool operator == (const TGetTablesParams & rhs) const
  {
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.pattern != rhs.__isset.pattern)
      return false;
    else if (__isset.pattern && !(pattern == rhs.pattern))
      return false;
    if (__isset.session != rhs.__isset.session)
      return false;
    else if (__isset.session && !(session == rhs.session))
      return false;
    return true;
  }
  bool operator != (const TGetTablesParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesParams &a, TGetTablesParams &b);

typedef struct _TGetTablesResult__isset {
  _TGetTablesResult__isset() : tables(false) {}
  bool tables;
} _TGetTablesResult__isset;

class TGetTablesResult {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  TGetTablesResult() {
  }

  virtual ~TGetTablesResult() throw() {}

  std::vector<std::string>  tables;

  _TGetTablesResult__isset __isset;

  void __set_tables(const std::vector<std::string> & val) {
    tables = val;
    __isset.tables = true;
  }

  bool operator == (const TGetTablesResult & rhs) const
  {
    if (!(tables == rhs.tables))
      return false;
    return true;
  }
  bool operator != (const TGetTablesResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetTablesResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetTablesResult &a, TGetTablesResult &b);

typedef struct _TGetDbsParams__isset {
  _TGetDbsParams__isset() : pattern(false), session(false) {}
  bool pattern;
  bool session;
} _TGetDbsParams__isset;

class TGetDbsParams {
 public:

  static const char* ascii_fingerprint; // = "3638EF8F336F9535838234C1738ABE08";
  static const uint8_t binary_fingerprint[16]; // = {0x36,0x38,0xEF,0x8F,0x33,0x6F,0x95,0x35,0x83,0x82,0x34,0xC1,0x73,0x8A,0xBE,0x08};

  TGetDbsParams() : pattern() {
  }

  virtual ~TGetDbsParams() throw() {}

  std::string pattern;
   ::impala::TSessionState session;

  _TGetDbsParams__isset __isset;

  void __set_pattern(const std::string& val) {
    pattern = val;
    __isset.pattern = true;
  }

  void __set_session(const  ::impala::TSessionState& val) {
    session = val;
    __isset.session = true;
  }

  bool operator == (const TGetDbsParams & rhs) const
  {
    if (__isset.pattern != rhs.__isset.pattern)
      return false;
    else if (__isset.pattern && !(pattern == rhs.pattern))
      return false;
    if (__isset.session != rhs.__isset.session)
      return false;
    else if (__isset.session && !(session == rhs.session))
      return false;
    return true;
  }
  bool operator != (const TGetDbsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDbsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDbsParams &a, TGetDbsParams &b);

typedef struct _TGetDbsResult__isset {
  _TGetDbsResult__isset() : dbs(false) {}
  bool dbs;
} _TGetDbsResult__isset;

class TGetDbsResult {
 public:

  static const char* ascii_fingerprint; // = "ACE4F644F0FDD289DDC4EE5B83BC13C0";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0xE4,0xF6,0x44,0xF0,0xFD,0xD2,0x89,0xDD,0xC4,0xEE,0x5B,0x83,0xBC,0x13,0xC0};

  TGetDbsResult() {
  }

  virtual ~TGetDbsResult() throw() {}

  std::vector<std::string>  dbs;

  _TGetDbsResult__isset __isset;

  void __set_dbs(const std::vector<std::string> & val) {
    dbs = val;
    __isset.dbs = true;
  }

  bool operator == (const TGetDbsResult & rhs) const
  {
    if (!(dbs == rhs.dbs))
      return false;
    return true;
  }
  bool operator != (const TGetDbsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDbsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDbsResult &a, TGetDbsResult &b);

typedef struct _TGetDataSrcsParams__isset {
  _TGetDataSrcsParams__isset() : pattern(false) {}
  bool pattern;
} _TGetDataSrcsParams__isset;

class TGetDataSrcsParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TGetDataSrcsParams() : pattern() {
  }

  virtual ~TGetDataSrcsParams() throw() {}

  std::string pattern;

  _TGetDataSrcsParams__isset __isset;

  void __set_pattern(const std::string& val) {
    pattern = val;
    __isset.pattern = true;
  }

  bool operator == (const TGetDataSrcsParams & rhs) const
  {
    if (__isset.pattern != rhs.__isset.pattern)
      return false;
    else if (__isset.pattern && !(pattern == rhs.pattern))
      return false;
    return true;
  }
  bool operator != (const TGetDataSrcsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDataSrcsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDataSrcsParams &a, TGetDataSrcsParams &b);


class TGetDataSrcsResult {
 public:

  static const char* ascii_fingerprint; // = "A7F2BC4780E8F8AE8540AC2742EA1AA3";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0xF2,0xBC,0x47,0x80,0xE8,0xF8,0xAE,0x85,0x40,0xAC,0x27,0x42,0xEA,0x1A,0xA3};

  TGetDataSrcsResult() {
  }

  virtual ~TGetDataSrcsResult() throw() {}

  std::vector<std::string>  data_src_names;
  std::vector<std::string>  locations;
  std::vector<std::string>  class_names;
  std::vector<std::string>  api_versions;

  void __set_data_src_names(const std::vector<std::string> & val) {
    data_src_names = val;
  }

  void __set_locations(const std::vector<std::string> & val) {
    locations = val;
  }

  void __set_class_names(const std::vector<std::string> & val) {
    class_names = val;
  }

  void __set_api_versions(const std::vector<std::string> & val) {
    api_versions = val;
  }

  bool operator == (const TGetDataSrcsResult & rhs) const
  {
    if (!(data_src_names == rhs.data_src_names))
      return false;
    if (!(locations == rhs.locations))
      return false;
    if (!(class_names == rhs.class_names))
      return false;
    if (!(api_versions == rhs.api_versions))
      return false;
    return true;
  }
  bool operator != (const TGetDataSrcsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetDataSrcsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetDataSrcsResult &a, TGetDataSrcsResult &b);


class TDescribeTableParams {
 public:

  static const char* ascii_fingerprint; // = "4F8ABE747D9A2DF14F7E84DDBE60D55C";
  static const uint8_t binary_fingerprint[16]; // = {0x4F,0x8A,0xBE,0x74,0x7D,0x9A,0x2D,0xF1,0x4F,0x7E,0x84,0xDD,0xBE,0x60,0xD5,0x5C};

  TDescribeTableParams() : db(), table_name(), output_style((TDescribeTableOutputStyle::type)0) {
  }

  virtual ~TDescribeTableParams() throw() {}

  std::string db;
  std::string table_name;
  TDescribeTableOutputStyle::type output_style;

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_output_style(const TDescribeTableOutputStyle::type val) {
    output_style = val;
  }

  bool operator == (const TDescribeTableParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(output_style == rhs.output_style))
      return false;
    return true;
  }
  bool operator != (const TDescribeTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescribeTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDescribeTableParams &a, TDescribeTableParams &b);


class TDescribeTableResult {
 public:

  static const char* ascii_fingerprint; // = "2323F026C25A0E93C06CCB1908E06698";
  static const uint8_t binary_fingerprint[16]; // = {0x23,0x23,0xF0,0x26,0xC2,0x5A,0x0E,0x93,0xC0,0x6C,0xCB,0x19,0x08,0xE0,0x66,0x98};

  TDescribeTableResult() {
  }

  virtual ~TDescribeTableResult() throw() {}

  std::vector< ::impala::TResultRow>  results;

  void __set_results(const std::vector< ::impala::TResultRow> & val) {
    results = val;
  }

  bool operator == (const TDescribeTableResult & rhs) const
  {
    if (!(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TDescribeTableResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDescribeTableResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDescribeTableResult &a, TDescribeTableResult &b);

typedef struct _TShowDataSrcsParams__isset {
  _TShowDataSrcsParams__isset() : show_pattern(false) {}
  bool show_pattern;
} _TShowDataSrcsParams__isset;

class TShowDataSrcsParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TShowDataSrcsParams() : show_pattern() {
  }

  virtual ~TShowDataSrcsParams() throw() {}

  std::string show_pattern;

  _TShowDataSrcsParams__isset __isset;

  void __set_show_pattern(const std::string& val) {
    show_pattern = val;
    __isset.show_pattern = true;
  }

  bool operator == (const TShowDataSrcsParams & rhs) const
  {
    if (__isset.show_pattern != rhs.__isset.show_pattern)
      return false;
    else if (__isset.show_pattern && !(show_pattern == rhs.show_pattern))
      return false;
    return true;
  }
  bool operator != (const TShowDataSrcsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowDataSrcsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowDataSrcsParams &a, TShowDataSrcsParams &b);

typedef struct _TShowDbsParams__isset {
  _TShowDbsParams__isset() : show_pattern(false) {}
  bool show_pattern;
} _TShowDbsParams__isset;

class TShowDbsParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TShowDbsParams() : show_pattern() {
  }

  virtual ~TShowDbsParams() throw() {}

  std::string show_pattern;

  _TShowDbsParams__isset __isset;

  void __set_show_pattern(const std::string& val) {
    show_pattern = val;
    __isset.show_pattern = true;
  }

  bool operator == (const TShowDbsParams & rhs) const
  {
    if (__isset.show_pattern != rhs.__isset.show_pattern)
      return false;
    else if (__isset.show_pattern && !(show_pattern == rhs.show_pattern))
      return false;
    return true;
  }
  bool operator != (const TShowDbsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowDbsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowDbsParams &a, TShowDbsParams &b);

typedef struct _TShowStatsParams__isset {
  _TShowStatsParams__isset() : table_name(false) {}
  bool table_name;
} _TShowStatsParams__isset;

class TShowStatsParams {
 public:

  static const char* ascii_fingerprint; // = "2C2DBA72DDCCFC94FC1FB269D11714F0";
  static const uint8_t binary_fingerprint[16]; // = {0x2C,0x2D,0xBA,0x72,0xDD,0xCC,0xFC,0x94,0xFC,0x1F,0xB2,0x69,0xD1,0x17,0x14,0xF0};

  TShowStatsParams() : is_show_col_stats(0) {
  }

  virtual ~TShowStatsParams() throw() {}

  bool is_show_col_stats;
   ::impala::TTableName table_name;

  _TShowStatsParams__isset __isset;

  void __set_is_show_col_stats(const bool val) {
    is_show_col_stats = val;
  }

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
    __isset.table_name = true;
  }

  bool operator == (const TShowStatsParams & rhs) const
  {
    if (!(is_show_col_stats == rhs.is_show_col_stats))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TShowStatsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowStatsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowStatsParams &a, TShowStatsParams &b);

typedef struct _TShowFunctionsParams__isset {
  _TShowFunctionsParams__isset() : type(false), db(false), show_pattern(false) {}
  bool type;
  bool db;
  bool show_pattern;
} _TShowFunctionsParams__isset;

class TShowFunctionsParams {
 public:

  static const char* ascii_fingerprint; // = "4347F5681F1B975578862DBCB1D9EC3E";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x47,0xF5,0x68,0x1F,0x1B,0x97,0x55,0x78,0x86,0x2D,0xBC,0xB1,0xD9,0xEC,0x3E};

  TShowFunctionsParams() : type(( ::impala::TFunctionType::type)0), db(), show_pattern() {
  }

  virtual ~TShowFunctionsParams() throw() {}

   ::impala::TFunctionType::type type;
  std::string db;
  std::string show_pattern;

  _TShowFunctionsParams__isset __isset;

  void __set_type(const  ::impala::TFunctionType::type val) {
    type = val;
    __isset.type = true;
  }

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_show_pattern(const std::string& val) {
    show_pattern = val;
    __isset.show_pattern = true;
  }

  bool operator == (const TShowFunctionsParams & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.show_pattern != rhs.__isset.show_pattern)
      return false;
    else if (__isset.show_pattern && !(show_pattern == rhs.show_pattern))
      return false;
    return true;
  }
  bool operator != (const TShowFunctionsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowFunctionsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowFunctionsParams &a, TShowFunctionsParams &b);

typedef struct _TShowTablesParams__isset {
  _TShowTablesParams__isset() : db(false), show_pattern(false) {}
  bool db;
  bool show_pattern;
} _TShowTablesParams__isset;

class TShowTablesParams {
 public:

  static const char* ascii_fingerprint; // = "D0297FC5011701BD87898CC36146A565";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

  TShowTablesParams() : db(), show_pattern() {
  }

  virtual ~TShowTablesParams() throw() {}

  std::string db;
  std::string show_pattern;

  _TShowTablesParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_show_pattern(const std::string& val) {
    show_pattern = val;
    __isset.show_pattern = true;
  }

  bool operator == (const TShowTablesParams & rhs) const
  {
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.show_pattern != rhs.__isset.show_pattern)
      return false;
    else if (__isset.show_pattern && !(show_pattern == rhs.show_pattern))
      return false;
    return true;
  }
  bool operator != (const TShowTablesParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TShowTablesParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TShowTablesParams &a, TShowTablesParams &b);

typedef struct _TGetFunctionsParams__isset {
  _TGetFunctionsParams__isset() : db(false), pattern(false), session(false) {}
  bool db;
  bool pattern;
  bool session;
} _TGetFunctionsParams__isset;

class TGetFunctionsParams {
 public:

  static const char* ascii_fingerprint; // = "4B6E0DF52F16D913D15C07A8810BDBA2";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0x6E,0x0D,0xF5,0x2F,0x16,0xD9,0x13,0xD1,0x5C,0x07,0xA8,0x81,0x0B,0xDB,0xA2};

  TGetFunctionsParams() : type(( ::impala::TFunctionType::type)0), db(), pattern() {
  }

  virtual ~TGetFunctionsParams() throw() {}

   ::impala::TFunctionType::type type;
  std::string db;
  std::string pattern;
   ::impala::TSessionState session;

  _TGetFunctionsParams__isset __isset;

  void __set_type(const  ::impala::TFunctionType::type val) {
    type = val;
  }

  void __set_db(const std::string& val) {
    db = val;
    __isset.db = true;
  }

  void __set_pattern(const std::string& val) {
    pattern = val;
    __isset.pattern = true;
  }

  void __set_session(const  ::impala::TSessionState& val) {
    session = val;
    __isset.session = true;
  }

  bool operator == (const TGetFunctionsParams & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.pattern != rhs.__isset.pattern)
      return false;
    else if (__isset.pattern && !(pattern == rhs.pattern))
      return false;
    if (__isset.session != rhs.__isset.session)
      return false;
    else if (__isset.session && !(session == rhs.session))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetFunctionsParams &a, TGetFunctionsParams &b);

typedef struct _TGetFunctionsResult__isset {
  _TGetFunctionsResult__isset() : fn_signatures(false), fn_ret_types(false) {}
  bool fn_signatures;
  bool fn_ret_types;
} _TGetFunctionsResult__isset;

class TGetFunctionsResult {
 public:

  static const char* ascii_fingerprint; // = "AA819045335EAFAB5C2FE456B4B9CC1C";
  static const uint8_t binary_fingerprint[16]; // = {0xAA,0x81,0x90,0x45,0x33,0x5E,0xAF,0xAB,0x5C,0x2F,0xE4,0x56,0xB4,0xB9,0xCC,0x1C};

  TGetFunctionsResult() {
  }

  virtual ~TGetFunctionsResult() throw() {}

  std::vector<std::string>  fn_signatures;
  std::vector<std::string>  fn_ret_types;

  _TGetFunctionsResult__isset __isset;

  void __set_fn_signatures(const std::vector<std::string> & val) {
    fn_signatures = val;
    __isset.fn_signatures = true;
  }

  void __set_fn_ret_types(const std::vector<std::string> & val) {
    fn_ret_types = val;
    __isset.fn_ret_types = true;
  }

  bool operator == (const TGetFunctionsResult & rhs) const
  {
    if (!(fn_signatures == rhs.fn_signatures))
      return false;
    if (!(fn_ret_types == rhs.fn_ret_types))
      return false;
    return true;
  }
  bool operator != (const TGetFunctionsResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetFunctionsResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetFunctionsResult &a, TGetFunctionsResult &b);


class TUseDbParams {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TUseDbParams() : db() {
  }

  virtual ~TUseDbParams() throw() {}

  std::string db;

  void __set_db(const std::string& val) {
    db = val;
  }

  bool operator == (const TUseDbParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    return true;
  }
  bool operator != (const TUseDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUseDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUseDbParams &a, TUseDbParams &b);


class TExplainResult {
 public:

  static const char* ascii_fingerprint; // = "2323F026C25A0E93C06CCB1908E06698";
  static const uint8_t binary_fingerprint[16]; // = {0x23,0x23,0xF0,0x26,0xC2,0x5A,0x0E,0x93,0xC0,0x6C,0xCB,0x19,0x08,0xE0,0x66,0x98};

  TExplainResult() {
  }

  virtual ~TExplainResult() throw() {}

  std::vector< ::impala::TResultRow>  results;

  void __set_results(const std::vector< ::impala::TResultRow> & val) {
    results = val;
  }

  bool operator == (const TExplainResult & rhs) const
  {
    if (!(results == rhs.results))
      return false;
    return true;
  }
  bool operator != (const TExplainResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExplainResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExplainResult &a, TExplainResult &b);

typedef struct _TFinalizeParams__isset {
  _TFinalizeParams__isset() : staging_dir(false), table_id(false) {}
  bool staging_dir;
  bool table_id;
} _TFinalizeParams__isset;

class TFinalizeParams {
 public:

  static const char* ascii_fingerprint; // = "8B694BA5EFBA110EC854C9CBC04861B6";
  static const uint8_t binary_fingerprint[16]; // = {0x8B,0x69,0x4B,0xA5,0xEF,0xBA,0x11,0x0E,0xC8,0x54,0xC9,0xCB,0xC0,0x48,0x61,0xB6};

  TFinalizeParams() : is_overwrite(0), hdfs_base_dir(), table_name(), table_db(), staging_dir(), table_id(0) {
  }

  virtual ~TFinalizeParams() throw() {}

  bool is_overwrite;
  std::string hdfs_base_dir;
  std::string table_name;
  std::string table_db;
  std::string staging_dir;
  int64_t table_id;

  _TFinalizeParams__isset __isset;

  void __set_is_overwrite(const bool val) {
    is_overwrite = val;
  }

  void __set_hdfs_base_dir(const std::string& val) {
    hdfs_base_dir = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_table_db(const std::string& val) {
    table_db = val;
  }

  void __set_staging_dir(const std::string& val) {
    staging_dir = val;
    __isset.staging_dir = true;
  }

  void __set_table_id(const int64_t val) {
    table_id = val;
    __isset.table_id = true;
  }

  bool operator == (const TFinalizeParams & rhs) const
  {
    if (!(is_overwrite == rhs.is_overwrite))
      return false;
    if (!(hdfs_base_dir == rhs.hdfs_base_dir))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (!(table_db == rhs.table_db))
      return false;
    if (__isset.staging_dir != rhs.__isset.staging_dir)
      return false;
    else if (__isset.staging_dir && !(staging_dir == rhs.staging_dir))
      return false;
    if (__isset.table_id != rhs.__isset.table_id)
      return false;
    else if (__isset.table_id && !(table_id == rhs.table_id))
      return false;
    return true;
  }
  bool operator != (const TFinalizeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TFinalizeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TFinalizeParams &a, TFinalizeParams &b);

typedef struct _TLoadDataReq__isset {
  _TLoadDataReq__isset() : partition_spec(false) {}
  bool partition_spec;
} _TLoadDataReq__isset;

class TLoadDataReq {
 public:

  static const char* ascii_fingerprint; // = "F5296D70596F63172462D7DECBF7C955";
  static const uint8_t binary_fingerprint[16]; // = {0xF5,0x29,0x6D,0x70,0x59,0x6F,0x63,0x17,0x24,0x62,0xD7,0xDE,0xCB,0xF7,0xC9,0x55};

  TLoadDataReq() : source_path(), overwrite(0) {
  }

  virtual ~TLoadDataReq() throw() {}

   ::impala::TTableName table_name;
  std::string source_path;
  bool overwrite;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TLoadDataReq__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_source_path(const std::string& val) {
    source_path = val;
  }

  void __set_overwrite(const bool val) {
    overwrite = val;
  }

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TLoadDataReq & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(source_path == rhs.source_path))
      return false;
    if (!(overwrite == rhs.overwrite))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TLoadDataReq &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLoadDataReq & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLoadDataReq &a, TLoadDataReq &b);


class TLoadDataResp {
 public:

  static const char* ascii_fingerprint; // = "F91C0031A4C34E80B0992AE6CDA28F3D";
  static const uint8_t binary_fingerprint[16]; // = {0xF9,0x1C,0x00,0x31,0xA4,0xC3,0x4E,0x80,0xB0,0x99,0x2A,0xE6,0xCD,0xA2,0x8F,0x3D};

  TLoadDataResp() {
  }

  virtual ~TLoadDataResp() throw() {}

   ::impala::TResultRow load_summary;

  void __set_load_summary(const  ::impala::TResultRow& val) {
    load_summary = val;
  }

  bool operator == (const TLoadDataResp & rhs) const
  {
    if (!(load_summary == rhs.load_summary))
      return false;
    return true;
  }
  bool operator != (const TLoadDataResp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TLoadDataResp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TLoadDataResp &a, TLoadDataResp &b);

typedef struct _TQueryExecRequest__isset {
  _TQueryExecRequest__isset() : desc_tbl(false), dest_fragment_idx(false), per_node_scan_ranges(false), result_set_metadata(false), finalize_params(false), query_plan(false), per_host_mem_req(false), per_host_vcores(false) {}
  bool desc_tbl;
  bool dest_fragment_idx;
  bool per_node_scan_ranges;
  bool result_set_metadata;
  bool finalize_params;
  bool query_plan;
  bool per_host_mem_req;
  bool per_host_vcores;
} _TQueryExecRequest__isset;

class TQueryExecRequest {
 public:

  static const char* ascii_fingerprint; // = "CB98E0B542FA0D10EA94D57535C73214";
  static const uint8_t binary_fingerprint[16]; // = {0xCB,0x98,0xE0,0xB5,0x42,0xFA,0x0D,0x10,0xEA,0x94,0xD5,0x75,0x35,0xC7,0x32,0x14};

  TQueryExecRequest() : query_plan(), stmt_type(( ::impala::TStmtType::type)0), per_host_mem_req(0), per_host_vcores(0) {
  }

  virtual ~TQueryExecRequest() throw() {}

   ::impala::TDescriptorTable desc_tbl;
  std::vector< ::impala::TPlanFragment>  fragments;
  std::vector<int32_t>  dest_fragment_idx;
  std::map< ::impala::TPlanNodeId, std::vector< ::impala::TScanRangeLocations> >  per_node_scan_ranges;
   ::impala::TResultSetMetadata result_set_metadata;
  TFinalizeParams finalize_params;
   ::impala::TQueryCtx query_ctx;
  std::string query_plan;
   ::impala::TStmtType::type stmt_type;
  int64_t per_host_mem_req;
  int16_t per_host_vcores;

  _TQueryExecRequest__isset __isset;

  void __set_desc_tbl(const  ::impala::TDescriptorTable& val) {
    desc_tbl = val;
    __isset.desc_tbl = true;
  }

  void __set_fragments(const std::vector< ::impala::TPlanFragment> & val) {
    fragments = val;
  }

  void __set_dest_fragment_idx(const std::vector<int32_t> & val) {
    dest_fragment_idx = val;
    __isset.dest_fragment_idx = true;
  }

  void __set_per_node_scan_ranges(const std::map< ::impala::TPlanNodeId, std::vector< ::impala::TScanRangeLocations> > & val) {
    per_node_scan_ranges = val;
    __isset.per_node_scan_ranges = true;
  }

  void __set_result_set_metadata(const  ::impala::TResultSetMetadata& val) {
    result_set_metadata = val;
    __isset.result_set_metadata = true;
  }

  void __set_finalize_params(const TFinalizeParams& val) {
    finalize_params = val;
    __isset.finalize_params = true;
  }

  void __set_query_ctx(const  ::impala::TQueryCtx& val) {
    query_ctx = val;
  }

  void __set_query_plan(const std::string& val) {
    query_plan = val;
    __isset.query_plan = true;
  }

  void __set_stmt_type(const  ::impala::TStmtType::type val) {
    stmt_type = val;
  }

  void __set_per_host_mem_req(const int64_t val) {
    per_host_mem_req = val;
    __isset.per_host_mem_req = true;
  }

  void __set_per_host_vcores(const int16_t val) {
    per_host_vcores = val;
    __isset.per_host_vcores = true;
  }

  bool operator == (const TQueryExecRequest & rhs) const
  {
    if (__isset.desc_tbl != rhs.__isset.desc_tbl)
      return false;
    else if (__isset.desc_tbl && !(desc_tbl == rhs.desc_tbl))
      return false;
    if (!(fragments == rhs.fragments))
      return false;
    if (__isset.dest_fragment_idx != rhs.__isset.dest_fragment_idx)
      return false;
    else if (__isset.dest_fragment_idx && !(dest_fragment_idx == rhs.dest_fragment_idx))
      return false;
    if (__isset.per_node_scan_ranges != rhs.__isset.per_node_scan_ranges)
      return false;
    else if (__isset.per_node_scan_ranges && !(per_node_scan_ranges == rhs.per_node_scan_ranges))
      return false;
    if (__isset.result_set_metadata != rhs.__isset.result_set_metadata)
      return false;
    else if (__isset.result_set_metadata && !(result_set_metadata == rhs.result_set_metadata))
      return false;
    if (__isset.finalize_params != rhs.__isset.finalize_params)
      return false;
    else if (__isset.finalize_params && !(finalize_params == rhs.finalize_params))
      return false;
    if (!(query_ctx == rhs.query_ctx))
      return false;
    if (__isset.query_plan != rhs.__isset.query_plan)
      return false;
    else if (__isset.query_plan && !(query_plan == rhs.query_plan))
      return false;
    if (!(stmt_type == rhs.stmt_type))
      return false;
    if (__isset.per_host_mem_req != rhs.__isset.per_host_mem_req)
      return false;
    else if (__isset.per_host_mem_req && !(per_host_mem_req == rhs.per_host_mem_req))
      return false;
    if (__isset.per_host_vcores != rhs.__isset.per_host_vcores)
      return false;
    else if (__isset.per_host_vcores && !(per_host_vcores == rhs.per_host_vcores))
      return false;
    return true;
  }
  bool operator != (const TQueryExecRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryExecRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryExecRequest &a, TQueryExecRequest &b);

typedef struct _TCatalogOpRequest__isset {
  _TCatalogOpRequest__isset() : use_db_params(false), describe_table_params(false), show_dbs_params(false), show_tables_params(false), show_fns_params(false), show_data_srcs_params(false), ddl_params(false), reset_metadata_params(false), show_stats_params(false), show_create_table_params(false) {}
  bool use_db_params;
  bool describe_table_params;
  bool show_dbs_params;
  bool show_tables_params;
  bool show_fns_params;
  bool show_data_srcs_params;
  bool ddl_params;
  bool reset_metadata_params;
  bool show_stats_params;
  bool show_create_table_params;
} _TCatalogOpRequest__isset;

class TCatalogOpRequest {
 public:

  static const char* ascii_fingerprint; // = "4C53DFBBEF8968EFE09ACCC7DE171750";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x53,0xDF,0xBB,0xEF,0x89,0x68,0xEF,0xE0,0x9A,0xCC,0xC7,0xDE,0x17,0x17,0x50};

  TCatalogOpRequest() : op_type((TCatalogOpType::type)0) {
  }

  virtual ~TCatalogOpRequest() throw() {}

  TCatalogOpType::type op_type;
  TUseDbParams use_db_params;
  TDescribeTableParams describe_table_params;
  TShowDbsParams show_dbs_params;
  TShowTablesParams show_tables_params;
  TShowFunctionsParams show_fns_params;
  TShowDataSrcsParams show_data_srcs_params;
   ::impala::TDdlExecRequest ddl_params;
   ::impala::TResetMetadataRequest reset_metadata_params;
  TShowStatsParams show_stats_params;
   ::impala::TTableName show_create_table_params;

  _TCatalogOpRequest__isset __isset;

  void __set_op_type(const TCatalogOpType::type val) {
    op_type = val;
  }

  void __set_use_db_params(const TUseDbParams& val) {
    use_db_params = val;
    __isset.use_db_params = true;
  }

  void __set_describe_table_params(const TDescribeTableParams& val) {
    describe_table_params = val;
    __isset.describe_table_params = true;
  }

  void __set_show_dbs_params(const TShowDbsParams& val) {
    show_dbs_params = val;
    __isset.show_dbs_params = true;
  }

  void __set_show_tables_params(const TShowTablesParams& val) {
    show_tables_params = val;
    __isset.show_tables_params = true;
  }

  void __set_show_fns_params(const TShowFunctionsParams& val) {
    show_fns_params = val;
    __isset.show_fns_params = true;
  }

  void __set_show_data_srcs_params(const TShowDataSrcsParams& val) {
    show_data_srcs_params = val;
    __isset.show_data_srcs_params = true;
  }

  void __set_ddl_params(const  ::impala::TDdlExecRequest& val) {
    ddl_params = val;
    __isset.ddl_params = true;
  }

  void __set_reset_metadata_params(const  ::impala::TResetMetadataRequest& val) {
    reset_metadata_params = val;
    __isset.reset_metadata_params = true;
  }

  void __set_show_stats_params(const TShowStatsParams& val) {
    show_stats_params = val;
    __isset.show_stats_params = true;
  }

  void __set_show_create_table_params(const  ::impala::TTableName& val) {
    show_create_table_params = val;
    __isset.show_create_table_params = true;
  }

  bool operator == (const TCatalogOpRequest & rhs) const
  {
    if (!(op_type == rhs.op_type))
      return false;
    if (__isset.use_db_params != rhs.__isset.use_db_params)
      return false;
    else if (__isset.use_db_params && !(use_db_params == rhs.use_db_params))
      return false;
    if (__isset.describe_table_params != rhs.__isset.describe_table_params)
      return false;
    else if (__isset.describe_table_params && !(describe_table_params == rhs.describe_table_params))
      return false;
    if (__isset.show_dbs_params != rhs.__isset.show_dbs_params)
      return false;
    else if (__isset.show_dbs_params && !(show_dbs_params == rhs.show_dbs_params))
      return false;
    if (__isset.show_tables_params != rhs.__isset.show_tables_params)
      return false;
    else if (__isset.show_tables_params && !(show_tables_params == rhs.show_tables_params))
      return false;
    if (__isset.show_fns_params != rhs.__isset.show_fns_params)
      return false;
    else if (__isset.show_fns_params && !(show_fns_params == rhs.show_fns_params))
      return false;
    if (__isset.show_data_srcs_params != rhs.__isset.show_data_srcs_params)
      return false;
    else if (__isset.show_data_srcs_params && !(show_data_srcs_params == rhs.show_data_srcs_params))
      return false;
    if (__isset.ddl_params != rhs.__isset.ddl_params)
      return false;
    else if (__isset.ddl_params && !(ddl_params == rhs.ddl_params))
      return false;
    if (__isset.reset_metadata_params != rhs.__isset.reset_metadata_params)
      return false;
    else if (__isset.reset_metadata_params && !(reset_metadata_params == rhs.reset_metadata_params))
      return false;
    if (__isset.show_stats_params != rhs.__isset.show_stats_params)
      return false;
    else if (__isset.show_stats_params && !(show_stats_params == rhs.show_stats_params))
      return false;
    if (__isset.show_create_table_params != rhs.__isset.show_create_table_params)
      return false;
    else if (__isset.show_create_table_params && !(show_create_table_params == rhs.show_create_table_params))
      return false;
    return true;
  }
  bool operator != (const TCatalogOpRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCatalogOpRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCatalogOpRequest &a, TCatalogOpRequest &b);

typedef struct _TMetadataOpRequest__isset {
  _TMetadataOpRequest__isset() : get_info_req(false), get_type_info_req(false), get_catalogs_req(false), get_schemas_req(false), get_tables_req(false), get_table_types_req(false), get_columns_req(false), get_functions_req(false), session(false) {}
  bool get_info_req;
  bool get_type_info_req;
  bool get_catalogs_req;
  bool get_schemas_req;
  bool get_tables_req;
  bool get_table_types_req;
  bool get_columns_req;
  bool get_functions_req;
  bool session;
} _TMetadataOpRequest__isset;

class TMetadataOpRequest {
 public:

  static const char* ascii_fingerprint; // = "B067515151CFBA1323FA6CFEC5825FDE";
  static const uint8_t binary_fingerprint[16]; // = {0xB0,0x67,0x51,0x51,0x51,0xCF,0xBA,0x13,0x23,0xFA,0x6C,0xFE,0xC5,0x82,0x5F,0xDE};

  TMetadataOpRequest() : opcode((TMetadataOpcode::type)0) {
  }

  virtual ~TMetadataOpRequest() throw() {}

  TMetadataOpcode::type opcode;
   ::apache::hive::service::cli::thrift::TGetInfoReq get_info_req;
   ::apache::hive::service::cli::thrift::TGetTypeInfoReq get_type_info_req;
   ::apache::hive::service::cli::thrift::TGetCatalogsReq get_catalogs_req;
   ::apache::hive::service::cli::thrift::TGetSchemasReq get_schemas_req;
   ::apache::hive::service::cli::thrift::TGetTablesReq get_tables_req;
   ::apache::hive::service::cli::thrift::TGetTableTypesReq get_table_types_req;
   ::apache::hive::service::cli::thrift::TGetColumnsReq get_columns_req;
   ::apache::hive::service::cli::thrift::TGetFunctionsReq get_functions_req;
   ::impala::TSessionState session;

  _TMetadataOpRequest__isset __isset;

  void __set_opcode(const TMetadataOpcode::type val) {
    opcode = val;
  }

  void __set_get_info_req(const  ::apache::hive::service::cli::thrift::TGetInfoReq& val) {
    get_info_req = val;
    __isset.get_info_req = true;
  }

  void __set_get_type_info_req(const  ::apache::hive::service::cli::thrift::TGetTypeInfoReq& val) {
    get_type_info_req = val;
    __isset.get_type_info_req = true;
  }

  void __set_get_catalogs_req(const  ::apache::hive::service::cli::thrift::TGetCatalogsReq& val) {
    get_catalogs_req = val;
    __isset.get_catalogs_req = true;
  }

  void __set_get_schemas_req(const  ::apache::hive::service::cli::thrift::TGetSchemasReq& val) {
    get_schemas_req = val;
    __isset.get_schemas_req = true;
  }

  void __set_get_tables_req(const  ::apache::hive::service::cli::thrift::TGetTablesReq& val) {
    get_tables_req = val;
    __isset.get_tables_req = true;
  }

  void __set_get_table_types_req(const  ::apache::hive::service::cli::thrift::TGetTableTypesReq& val) {
    get_table_types_req = val;
    __isset.get_table_types_req = true;
  }

  void __set_get_columns_req(const  ::apache::hive::service::cli::thrift::TGetColumnsReq& val) {
    get_columns_req = val;
    __isset.get_columns_req = true;
  }

  void __set_get_functions_req(const  ::apache::hive::service::cli::thrift::TGetFunctionsReq& val) {
    get_functions_req = val;
    __isset.get_functions_req = true;
  }

  void __set_session(const  ::impala::TSessionState& val) {
    session = val;
    __isset.session = true;
  }

  bool operator == (const TMetadataOpRequest & rhs) const
  {
    if (!(opcode == rhs.opcode))
      return false;
    if (__isset.get_info_req != rhs.__isset.get_info_req)
      return false;
    else if (__isset.get_info_req && !(get_info_req == rhs.get_info_req))
      return false;
    if (__isset.get_type_info_req != rhs.__isset.get_type_info_req)
      return false;
    else if (__isset.get_type_info_req && !(get_type_info_req == rhs.get_type_info_req))
      return false;
    if (__isset.get_catalogs_req != rhs.__isset.get_catalogs_req)
      return false;
    else if (__isset.get_catalogs_req && !(get_catalogs_req == rhs.get_catalogs_req))
      return false;
    if (__isset.get_schemas_req != rhs.__isset.get_schemas_req)
      return false;
    else if (__isset.get_schemas_req && !(get_schemas_req == rhs.get_schemas_req))
      return false;
    if (__isset.get_tables_req != rhs.__isset.get_tables_req)
      return false;
    else if (__isset.get_tables_req && !(get_tables_req == rhs.get_tables_req))
      return false;
    if (__isset.get_table_types_req != rhs.__isset.get_table_types_req)
      return false;
    else if (__isset.get_table_types_req && !(get_table_types_req == rhs.get_table_types_req))
      return false;
    if (__isset.get_columns_req != rhs.__isset.get_columns_req)
      return false;
    else if (__isset.get_columns_req && !(get_columns_req == rhs.get_columns_req))
      return false;
    if (__isset.get_functions_req != rhs.__isset.get_functions_req)
      return false;
    else if (__isset.get_functions_req && !(get_functions_req == rhs.get_functions_req))
      return false;
    if (__isset.session != rhs.__isset.session)
      return false;
    else if (__isset.session && !(session == rhs.session))
      return false;
    return true;
  }
  bool operator != (const TMetadataOpRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TMetadataOpRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TMetadataOpRequest &a, TMetadataOpRequest &b);


class TAccessEvent {
 public:

  static const char* ascii_fingerprint; // = "D9F4CFE2F293A8B1052FD3031DD2C847";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xF4,0xCF,0xE2,0xF2,0x93,0xA8,0xB1,0x05,0x2F,0xD3,0x03,0x1D,0xD2,0xC8,0x47};

  TAccessEvent() : name(), object_type(( ::impala::TCatalogObjectType::type)0), privilege() {
  }

  virtual ~TAccessEvent() throw() {}

  std::string name;
   ::impala::TCatalogObjectType::type object_type;
  std::string privilege;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_object_type(const  ::impala::TCatalogObjectType::type val) {
    object_type = val;
  }

  void __set_privilege(const std::string& val) {
    privilege = val;
  }

  bool operator == (const TAccessEvent & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(object_type == rhs.object_type))
      return false;
    if (!(privilege == rhs.privilege))
      return false;
    return true;
  }
  bool operator != (const TAccessEvent &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAccessEvent & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAccessEvent &a, TAccessEvent &b);

typedef struct _TExecRequest__isset {
  _TExecRequest__isset() : query_exec_request(false), catalog_op_request(false), result_set_metadata(false), explain_result(false), load_data_request(false), access_events(false) {}
  bool query_exec_request;
  bool catalog_op_request;
  bool result_set_metadata;
  bool explain_result;
  bool load_data_request;
  bool access_events;
} _TExecRequest__isset;

class TExecRequest {
 public:

  static const char* ascii_fingerprint; // = "731F71D800FE5482B801EDA636A4E908";
  static const uint8_t binary_fingerprint[16]; // = {0x73,0x1F,0x71,0xD8,0x00,0xFE,0x54,0x82,0xB8,0x01,0xED,0xA6,0x36,0xA4,0xE9,0x08};

  TExecRequest() : stmt_type(( ::impala::TStmtType::type)0) {
  }

  virtual ~TExecRequest() throw() {}

   ::impala::TStmtType::type stmt_type;
   ::impala::TQueryOptions query_options;
  TQueryExecRequest query_exec_request;
  TCatalogOpRequest catalog_op_request;
   ::impala::TResultSetMetadata result_set_metadata;
  TExplainResult explain_result;
  TLoadDataReq load_data_request;
  std::vector<TAccessEvent>  access_events;
  std::vector<std::string>  analysis_warnings;

  _TExecRequest__isset __isset;

  void __set_stmt_type(const  ::impala::TStmtType::type val) {
    stmt_type = val;
  }

  void __set_query_options(const  ::impala::TQueryOptions& val) {
    query_options = val;
  }

  void __set_query_exec_request(const TQueryExecRequest& val) {
    query_exec_request = val;
    __isset.query_exec_request = true;
  }

  void __set_catalog_op_request(const TCatalogOpRequest& val) {
    catalog_op_request = val;
    __isset.catalog_op_request = true;
  }

  void __set_result_set_metadata(const  ::impala::TResultSetMetadata& val) {
    result_set_metadata = val;
    __isset.result_set_metadata = true;
  }

  void __set_explain_result(const TExplainResult& val) {
    explain_result = val;
    __isset.explain_result = true;
  }

  void __set_load_data_request(const TLoadDataReq& val) {
    load_data_request = val;
    __isset.load_data_request = true;
  }

  void __set_access_events(const std::vector<TAccessEvent> & val) {
    access_events = val;
    __isset.access_events = true;
  }

  void __set_analysis_warnings(const std::vector<std::string> & val) {
    analysis_warnings = val;
  }

  bool operator == (const TExecRequest & rhs) const
  {
    if (!(stmt_type == rhs.stmt_type))
      return false;
    if (!(query_options == rhs.query_options))
      return false;
    if (__isset.query_exec_request != rhs.__isset.query_exec_request)
      return false;
    else if (__isset.query_exec_request && !(query_exec_request == rhs.query_exec_request))
      return false;
    if (__isset.catalog_op_request != rhs.__isset.catalog_op_request)
      return false;
    else if (__isset.catalog_op_request && !(catalog_op_request == rhs.catalog_op_request))
      return false;
    if (__isset.result_set_metadata != rhs.__isset.result_set_metadata)
      return false;
    else if (__isset.result_set_metadata && !(result_set_metadata == rhs.result_set_metadata))
      return false;
    if (__isset.explain_result != rhs.__isset.explain_result)
      return false;
    else if (__isset.explain_result && !(explain_result == rhs.explain_result))
      return false;
    if (__isset.load_data_request != rhs.__isset.load_data_request)
      return false;
    else if (__isset.load_data_request && !(load_data_request == rhs.load_data_request))
      return false;
    if (__isset.access_events != rhs.__isset.access_events)
      return false;
    else if (__isset.access_events && !(access_events == rhs.access_events))
      return false;
    if (!(analysis_warnings == rhs.analysis_warnings))
      return false;
    return true;
  }
  bool operator != (const TExecRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecRequest &a, TExecRequest &b);


class TCacheJarParams {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TCacheJarParams() : hdfs_location() {
  }

  virtual ~TCacheJarParams() throw() {}

  std::string hdfs_location;

  void __set_hdfs_location(const std::string& val) {
    hdfs_location = val;
  }

  bool operator == (const TCacheJarParams & rhs) const
  {
    if (!(hdfs_location == rhs.hdfs_location))
      return false;
    return true;
  }
  bool operator != (const TCacheJarParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCacheJarParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCacheJarParams &a, TCacheJarParams &b);

typedef struct _TCacheJarResult__isset {
  _TCacheJarResult__isset() : local_path(false) {}
  bool local_path;
} _TCacheJarResult__isset;

class TCacheJarResult {
 public:

  static const char* ascii_fingerprint; // = "3D3D48AAE44702453D9901338EB31766";
  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x3D,0x48,0xAA,0xE4,0x47,0x02,0x45,0x3D,0x99,0x01,0x33,0x8E,0xB3,0x17,0x66};

  TCacheJarResult() : local_path() {
  }

  virtual ~TCacheJarResult() throw() {}

   ::impala::TStatus status;
  std::string local_path;

  _TCacheJarResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
  }

  void __set_local_path(const std::string& val) {
    local_path = val;
    __isset.local_path = true;
  }

  bool operator == (const TCacheJarResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.local_path != rhs.__isset.local_path)
      return false;
    else if (__isset.local_path && !(local_path == rhs.local_path))
      return false;
    return true;
  }
  bool operator != (const TCacheJarResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCacheJarResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCacheJarResult &a, TCacheJarResult &b);

typedef struct _TSymbolLookupParams__isset {
  _TSymbolLookupParams__isset() : ret_arg_type(false) {}
  bool ret_arg_type;
} _TSymbolLookupParams__isset;

class TSymbolLookupParams {
 public:

  static const char* ascii_fingerprint; // = "EB792BFC0DF25194EB104E969756B066";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x79,0x2B,0xFC,0x0D,0xF2,0x51,0x94,0xEB,0x10,0x4E,0x96,0x97,0x56,0xB0,0x66};

  TSymbolLookupParams() : location(), symbol(), fn_binary_type(( ::impala::TFunctionBinaryType::type)0), has_var_args(0), symbol_type((TSymbolType::type)0) {
  }

  virtual ~TSymbolLookupParams() throw() {}

  std::string location;
  std::string symbol;
   ::impala::TFunctionBinaryType::type fn_binary_type;
  std::vector< ::impala::TColumnType>  arg_types;
  bool has_var_args;
   ::impala::TColumnType ret_arg_type;
  TSymbolType::type symbol_type;

  _TSymbolLookupParams__isset __isset;

  void __set_location(const std::string& val) {
    location = val;
  }

  void __set_symbol(const std::string& val) {
    symbol = val;
  }

  void __set_fn_binary_type(const  ::impala::TFunctionBinaryType::type val) {
    fn_binary_type = val;
  }

  void __set_arg_types(const std::vector< ::impala::TColumnType> & val) {
    arg_types = val;
  }

  void __set_has_var_args(const bool val) {
    has_var_args = val;
  }

  void __set_ret_arg_type(const  ::impala::TColumnType& val) {
    ret_arg_type = val;
    __isset.ret_arg_type = true;
  }

  void __set_symbol_type(const TSymbolType::type val) {
    symbol_type = val;
  }

  bool operator == (const TSymbolLookupParams & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (!(symbol == rhs.symbol))
      return false;
    if (!(fn_binary_type == rhs.fn_binary_type))
      return false;
    if (!(arg_types == rhs.arg_types))
      return false;
    if (!(has_var_args == rhs.has_var_args))
      return false;
    if (__isset.ret_arg_type != rhs.__isset.ret_arg_type)
      return false;
    else if (__isset.ret_arg_type && !(ret_arg_type == rhs.ret_arg_type))
      return false;
    if (!(symbol_type == rhs.symbol_type))
      return false;
    return true;
  }
  bool operator != (const TSymbolLookupParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSymbolLookupParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSymbolLookupParams &a, TSymbolLookupParams &b);

typedef struct _TSymbolLookupResult__isset {
  _TSymbolLookupResult__isset() : symbol(false), error_msg(false) {}
  bool symbol;
  bool error_msg;
} _TSymbolLookupResult__isset;

class TSymbolLookupResult {
 public:

  static const char* ascii_fingerprint; // = "4347F5681F1B975578862DBCB1D9EC3E";
  static const uint8_t binary_fingerprint[16]; // = {0x43,0x47,0xF5,0x68,0x1F,0x1B,0x97,0x55,0x78,0x86,0x2D,0xBC,0xB1,0xD9,0xEC,0x3E};

  TSymbolLookupResult() : result_code((TSymbolLookupResultCode::type)0), symbol(), error_msg() {
  }

  virtual ~TSymbolLookupResult() throw() {}

  TSymbolLookupResultCode::type result_code;
  std::string symbol;
  std::string error_msg;

  _TSymbolLookupResult__isset __isset;

  void __set_result_code(const TSymbolLookupResultCode::type val) {
    result_code = val;
  }

  void __set_symbol(const std::string& val) {
    symbol = val;
    __isset.symbol = true;
  }

  void __set_error_msg(const std::string& val) {
    error_msg = val;
    __isset.error_msg = true;
  }

  bool operator == (const TSymbolLookupResult & rhs) const
  {
    if (!(result_code == rhs.result_code))
      return false;
    if (__isset.symbol != rhs.__isset.symbol)
      return false;
    else if (__isset.symbol && !(symbol == rhs.symbol))
      return false;
    if (__isset.error_msg != rhs.__isset.error_msg)
      return false;
    else if (__isset.error_msg && !(error_msg == rhs.error_msg))
      return false;
    return true;
  }
  bool operator != (const TSymbolLookupResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSymbolLookupResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSymbolLookupResult &a, TSymbolLookupResult &b);


class TUpdateCatalogCacheRequest {
 public:

  static const char* ascii_fingerprint; // = "E873389B47A7F6CD092B2284BD6C28E6";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x73,0x38,0x9B,0x47,0xA7,0xF6,0xCD,0x09,0x2B,0x22,0x84,0xBD,0x6C,0x28,0xE6};

  TUpdateCatalogCacheRequest() : is_delta(0) {
  }

  virtual ~TUpdateCatalogCacheRequest() throw() {}

  bool is_delta;
   ::impala::TUniqueId catalog_service_id;
  std::vector< ::impala::TCatalogObject>  updated_objects;
  std::vector< ::impala::TCatalogObject>  removed_objects;

  void __set_is_delta(const bool val) {
    is_delta = val;
  }

  void __set_catalog_service_id(const  ::impala::TUniqueId& val) {
    catalog_service_id = val;
  }

  void __set_updated_objects(const std::vector< ::impala::TCatalogObject> & val) {
    updated_objects = val;
  }

  void __set_removed_objects(const std::vector< ::impala::TCatalogObject> & val) {
    removed_objects = val;
  }

  bool operator == (const TUpdateCatalogCacheRequest & rhs) const
  {
    if (!(is_delta == rhs.is_delta))
      return false;
    if (!(catalog_service_id == rhs.catalog_service_id))
      return false;
    if (!(updated_objects == rhs.updated_objects))
      return false;
    if (!(removed_objects == rhs.removed_objects))
      return false;
    return true;
  }
  bool operator != (const TUpdateCatalogCacheRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUpdateCatalogCacheRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUpdateCatalogCacheRequest &a, TUpdateCatalogCacheRequest &b);


class TUpdateCatalogCacheResponse {
 public:

  static const char* ascii_fingerprint; // = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

  TUpdateCatalogCacheResponse() {
  }

  virtual ~TUpdateCatalogCacheResponse() throw() {}

   ::impala::TUniqueId catalog_service_id;

  void __set_catalog_service_id(const  ::impala::TUniqueId& val) {
    catalog_service_id = val;
  }

  bool operator == (const TUpdateCatalogCacheResponse & rhs) const
  {
    if (!(catalog_service_id == rhs.catalog_service_id))
      return false;
    return true;
  }
  bool operator != (const TUpdateCatalogCacheResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUpdateCatalogCacheResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUpdateCatalogCacheResponse &a, TUpdateCatalogCacheResponse &b);


class TJvmMemoryPool {
 public:

  static const char* ascii_fingerprint; // = "0437953E4726EDDFACCF494D2D77DCF9";
  static const uint8_t binary_fingerprint[16]; // = {0x04,0x37,0x95,0x3E,0x47,0x26,0xED,0xDF,0xAC,0xCF,0x49,0x4D,0x2D,0x77,0xDC,0xF9};

  TJvmMemoryPool() : committed(0), init(0), max(0), used(0), peak_committed(0), peak_init(0), peak_max(0), peak_used(0), name() {
  }

  virtual ~TJvmMemoryPool() throw() {}

  int64_t committed;
  int64_t init;
  int64_t max;
  int64_t used;
  int64_t peak_committed;
  int64_t peak_init;
  int64_t peak_max;
  int64_t peak_used;
  std::string name;

  void __set_committed(const int64_t val) {
    committed = val;
  }

  void __set_init(const int64_t val) {
    init = val;
  }

  void __set_max(const int64_t val) {
    max = val;
  }

  void __set_used(const int64_t val) {
    used = val;
  }

  void __set_peak_committed(const int64_t val) {
    peak_committed = val;
  }

  void __set_peak_init(const int64_t val) {
    peak_init = val;
  }

  void __set_peak_max(const int64_t val) {
    peak_max = val;
  }

  void __set_peak_used(const int64_t val) {
    peak_used = val;
  }

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const TJvmMemoryPool & rhs) const
  {
    if (!(committed == rhs.committed))
      return false;
    if (!(init == rhs.init))
      return false;
    if (!(max == rhs.max))
      return false;
    if (!(used == rhs.used))
      return false;
    if (!(peak_committed == rhs.peak_committed))
      return false;
    if (!(peak_init == rhs.peak_init))
      return false;
    if (!(peak_max == rhs.peak_max))
      return false;
    if (!(peak_used == rhs.peak_used))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const TJvmMemoryPool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TJvmMemoryPool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TJvmMemoryPool &a, TJvmMemoryPool &b);

typedef struct _TGetJvmMetricsRequest__isset {
  _TGetJvmMetricsRequest__isset() : memory_pool(false) {}
  bool memory_pool;
} _TGetJvmMetricsRequest__isset;

class TGetJvmMetricsRequest {
 public:

  static const char* ascii_fingerprint; // = "EB04A806CFFC9025AEE48CFFDC378A86";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x04,0xA8,0x06,0xCF,0xFC,0x90,0x25,0xAE,0xE4,0x8C,0xFF,0xDC,0x37,0x8A,0x86};

  TGetJvmMetricsRequest() : get_all(0), memory_pool() {
  }

  virtual ~TGetJvmMetricsRequest() throw() {}

  bool get_all;
  std::string memory_pool;

  _TGetJvmMetricsRequest__isset __isset;

  void __set_get_all(const bool val) {
    get_all = val;
  }

  void __set_memory_pool(const std::string& val) {
    memory_pool = val;
    __isset.memory_pool = true;
  }

  bool operator == (const TGetJvmMetricsRequest & rhs) const
  {
    if (!(get_all == rhs.get_all))
      return false;
    if (__isset.memory_pool != rhs.__isset.memory_pool)
      return false;
    else if (__isset.memory_pool && !(memory_pool == rhs.memory_pool))
      return false;
    return true;
  }
  bool operator != (const TGetJvmMetricsRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetJvmMetricsRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetJvmMetricsRequest &a, TGetJvmMetricsRequest &b);


class TGetJvmMetricsResponse {
 public:

  static const char* ascii_fingerprint; // = "EB8E6F8E626AC8B1587098880D0E1107";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x8E,0x6F,0x8E,0x62,0x6A,0xC8,0xB1,0x58,0x70,0x98,0x88,0x0D,0x0E,0x11,0x07};

  TGetJvmMetricsResponse() {
  }

  virtual ~TGetJvmMetricsResponse() throw() {}

  std::vector<TJvmMemoryPool>  memory_pools;

  void __set_memory_pools(const std::vector<TJvmMemoryPool> & val) {
    memory_pools = val;
  }

  bool operator == (const TGetJvmMetricsResponse & rhs) const
  {
    if (!(memory_pools == rhs.memory_pools))
      return false;
    return true;
  }
  bool operator != (const TGetJvmMetricsResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetJvmMetricsResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetJvmMetricsResponse &a, TGetJvmMetricsResponse &b);


class TGetHadoopConfigRequest {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TGetHadoopConfigRequest() : name() {
  }

  virtual ~TGetHadoopConfigRequest() throw() {}

  std::string name;

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const TGetHadoopConfigRequest & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const TGetHadoopConfigRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetHadoopConfigRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetHadoopConfigRequest &a, TGetHadoopConfigRequest &b);

typedef struct _TGetHadoopConfigResponse__isset {
  _TGetHadoopConfigResponse__isset() : value(false) {}
  bool value;
} _TGetHadoopConfigResponse__isset;

class TGetHadoopConfigResponse {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TGetHadoopConfigResponse() : value() {
  }

  virtual ~TGetHadoopConfigResponse() throw() {}

  std::string value;

  _TGetHadoopConfigResponse__isset __isset;

  void __set_value(const std::string& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TGetHadoopConfigResponse & rhs) const
  {
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TGetHadoopConfigResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetHadoopConfigResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetHadoopConfigResponse &a, TGetHadoopConfigResponse &b);

} // namespace

#endif
