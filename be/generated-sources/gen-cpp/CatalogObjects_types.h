/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef CatalogObjects_TYPES_H
#define CatalogObjects_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Exprs_types.h"
#include "Status_types.h"
#include "Types_types.h"
#include "hive_metastore_types.h"


namespace impala {

struct TCatalogObjectType {
  enum type {
    UNKNOWN = 0,
    CATALOG = 1,
    DATABASE = 2,
    TABLE = 3,
    VIEW = 4,
    FUNCTION = 5,
    DATA_SOURCE = 6,
    ROLE = 7,
    PRIVILEGE = 8,
    HDFS_CACHE_POOL = 9
  };
};

extern const std::map<int, const char*> _TCatalogObjectType_VALUES_TO_NAMES;

struct TTableType {
  enum type {
    HDFS_TABLE = 0,
    HBASE_TABLE = 1,
    VIEW = 2,
    DATA_SOURCE_TABLE = 3
  };
};

extern const std::map<int, const char*> _TTableType_VALUES_TO_NAMES;

struct THdfsFileFormat {
  enum type {
    TEXT = 0,
    LZO_TEXT = 1,
    RC_FILE = 2,
    SEQUENCE_FILE = 3,
    AVRO = 4,
    PARQUET = 5
  };
};

extern const std::map<int, const char*> _THdfsFileFormat_VALUES_TO_NAMES;

struct THdfsCompression {
  enum type {
    NONE = 0,
    DEFAULT = 1,
    GZIP = 2,
    DEFLATE = 3,
    BZIP2 = 4,
    SNAPPY = 5,
    SNAPPY_BLOCKED = 6,
    LZO = 7,
    LZ4 = 8
  };
};

extern const std::map<int, const char*> _THdfsCompression_VALUES_TO_NAMES;

struct TTablePropertyType {
  enum type {
    TBL_PROPERTY = 0,
    SERDE_PROPERTY = 1
  };
};

extern const std::map<int, const char*> _TTablePropertyType_VALUES_TO_NAMES;

struct TAccessLevel {
  enum type {
    NONE = 0,
    READ_WRITE = 1,
    READ_ONLY = 2,
    WRITE_ONLY = 3
  };
};

extern const std::map<int, const char*> _TAccessLevel_VALUES_TO_NAMES;

struct TPrivilegeScope {
  enum type {
    SERVER = 0,
    URI = 1,
    DATABASE = 2,
    TABLE = 3
  };
};

extern const std::map<int, const char*> _TPrivilegeScope_VALUES_TO_NAMES;


class TPartitionKeyValue {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TPartitionKeyValue() : name(), value() {
  }

  virtual ~TPartitionKeyValue() throw() {}

  std::string name;
  std::string value;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_value(const std::string& val) {
    value = val;
  }

  bool operator == (const TPartitionKeyValue & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TPartitionKeyValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPartitionKeyValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPartitionKeyValue &a, TPartitionKeyValue &b);


class TTableName {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TTableName() : db_name(), table_name() {
  }

  virtual ~TTableName() throw() {}

  std::string db_name;
  std::string table_name;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  bool operator == (const TTableName & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    return true;
  }
  bool operator != (const TTableName &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableName & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableName &a, TTableName &b);


class TTableStats {
 public:

  static const char* ascii_fingerprint; // = "56A59CE7FFAF82BCA8A19FAACDE4FB75";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xA5,0x9C,0xE7,0xFF,0xAF,0x82,0xBC,0xA8,0xA1,0x9F,0xAA,0xCD,0xE4,0xFB,0x75};

  TTableStats() : num_rows(0) {
  }

  virtual ~TTableStats() throw() {}

  int64_t num_rows;

  void __set_num_rows(const int64_t val) {
    num_rows = val;
  }

  bool operator == (const TTableStats & rhs) const
  {
    if (!(num_rows == rhs.num_rows))
      return false;
    return true;
  }
  bool operator != (const TTableStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableStats &a, TTableStats &b);


class TColumnStats {
 public:

  static const char* ascii_fingerprint; // = "D5FF58B203C57D2B1EF98050D612DB56";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xFF,0x58,0xB2,0x03,0xC5,0x7D,0x2B,0x1E,0xF9,0x80,0x50,0xD6,0x12,0xDB,0x56};

  TColumnStats() : avg_size(0), max_size(0), num_distinct_values(0), num_nulls(0) {
  }

  virtual ~TColumnStats() throw() {}

  double avg_size;
  int64_t max_size;
  int64_t num_distinct_values;
  int64_t num_nulls;

  void __set_avg_size(const double val) {
    avg_size = val;
  }

  void __set_max_size(const int64_t val) {
    max_size = val;
  }

  void __set_num_distinct_values(const int64_t val) {
    num_distinct_values = val;
  }

  void __set_num_nulls(const int64_t val) {
    num_nulls = val;
  }

  bool operator == (const TColumnStats & rhs) const
  {
    if (!(avg_size == rhs.avg_size))
      return false;
    if (!(max_size == rhs.max_size))
      return false;
    if (!(num_distinct_values == rhs.num_distinct_values))
      return false;
    if (!(num_nulls == rhs.num_nulls))
      return false;
    return true;
  }
  bool operator != (const TColumnStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnStats &a, TColumnStats &b);

typedef struct _TColumn__isset {
  _TColumn__isset() : comment(false), col_stats(false), position(false), is_hbase_column(false), column_family(false), column_qualifier(false), is_binary(false) {}
  bool comment;
  bool col_stats;
  bool position;
  bool is_hbase_column;
  bool column_family;
  bool column_qualifier;
  bool is_binary;
} _TColumn__isset;

class TColumn {
 public:

  static const char* ascii_fingerprint; // = "B50C1729ADACAD51D22BB2F03EA74DE6";
  static const uint8_t binary_fingerprint[16]; // = {0xB5,0x0C,0x17,0x29,0xAD,0xAC,0xAD,0x51,0xD2,0x2B,0xB2,0xF0,0x3E,0xA7,0x4D,0xE6};

  TColumn() : columnName(), comment(), position(0), is_hbase_column(0), column_family(), column_qualifier(), is_binary(0) {
  }

  virtual ~TColumn() throw() {}

  std::string columnName;
   ::impala::TColumnType columnType;
  std::string comment;
  TColumnStats col_stats;
  int32_t position;
  bool is_hbase_column;
  std::string column_family;
  std::string column_qualifier;
  bool is_binary;

  _TColumn__isset __isset;

  void __set_columnName(const std::string& val) {
    columnName = val;
  }

  void __set_columnType(const  ::impala::TColumnType& val) {
    columnType = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_col_stats(const TColumnStats& val) {
    col_stats = val;
    __isset.col_stats = true;
  }

  void __set_position(const int32_t val) {
    position = val;
    __isset.position = true;
  }

  void __set_is_hbase_column(const bool val) {
    is_hbase_column = val;
    __isset.is_hbase_column = true;
  }

  void __set_column_family(const std::string& val) {
    column_family = val;
    __isset.column_family = true;
  }

  void __set_column_qualifier(const std::string& val) {
    column_qualifier = val;
    __isset.column_qualifier = true;
  }

  void __set_is_binary(const bool val) {
    is_binary = val;
    __isset.is_binary = true;
  }

  bool operator == (const TColumn & rhs) const
  {
    if (!(columnName == rhs.columnName))
      return false;
    if (!(columnType == rhs.columnType))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.col_stats != rhs.__isset.col_stats)
      return false;
    else if (__isset.col_stats && !(col_stats == rhs.col_stats))
      return false;
    if (__isset.position != rhs.__isset.position)
      return false;
    else if (__isset.position && !(position == rhs.position))
      return false;
    if (__isset.is_hbase_column != rhs.__isset.is_hbase_column)
      return false;
    else if (__isset.is_hbase_column && !(is_hbase_column == rhs.is_hbase_column))
      return false;
    if (__isset.column_family != rhs.__isset.column_family)
      return false;
    else if (__isset.column_family && !(column_family == rhs.column_family))
      return false;
    if (__isset.column_qualifier != rhs.__isset.column_qualifier)
      return false;
    else if (__isset.column_qualifier && !(column_qualifier == rhs.column_qualifier))
      return false;
    if (__isset.is_binary != rhs.__isset.is_binary)
      return false;
    else if (__isset.is_binary && !(is_binary == rhs.is_binary))
      return false;
    return true;
  }
  bool operator != (const TColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumn &a, TColumn &b);

typedef struct _THdfsFileBlock__isset {
  _THdfsFileBlock__isset() : disk_ids(false) {}
  bool disk_ids;
} _THdfsFileBlock__isset;

class THdfsFileBlock {
 public:

  static const char* ascii_fingerprint; // = "C8196C2B7EBDDD72F1AECAB537F8D27A";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x19,0x6C,0x2B,0x7E,0xBD,0xDD,0x72,0xF1,0xAE,0xCA,0xB5,0x37,0xF8,0xD2,0x7A};

  THdfsFileBlock() : offset(0), length(0) {
  }

  virtual ~THdfsFileBlock() throw() {}

  int64_t offset;
  int64_t length;
  std::vector<int32_t>  replica_host_idxs;
  std::vector<int32_t>  disk_ids;

  _THdfsFileBlock__isset __isset;

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_replica_host_idxs(const std::vector<int32_t> & val) {
    replica_host_idxs = val;
  }

  void __set_disk_ids(const std::vector<int32_t> & val) {
    disk_ids = val;
    __isset.disk_ids = true;
  }

  bool operator == (const THdfsFileBlock & rhs) const
  {
    if (!(offset == rhs.offset))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(replica_host_idxs == rhs.replica_host_idxs))
      return false;
    if (__isset.disk_ids != rhs.__isset.disk_ids)
      return false;
    else if (__isset.disk_ids && !(disk_ids == rhs.disk_ids))
      return false;
    return true;
  }
  bool operator != (const THdfsFileBlock &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileBlock & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileBlock &a, THdfsFileBlock &b);


class THdfsFileDesc {
 public:

  static const char* ascii_fingerprint; // = "5C0597FF07EE22370218576E5B5F63E6";
  static const uint8_t binary_fingerprint[16]; // = {0x5C,0x05,0x97,0xFF,0x07,0xEE,0x22,0x37,0x02,0x18,0x57,0x6E,0x5B,0x5F,0x63,0xE6};

  THdfsFileDesc() : file_name(), length(0), compression((THdfsCompression::type)0), last_modification_time(0) {
  }

  virtual ~THdfsFileDesc() throw() {}

  std::string file_name;
  int64_t length;
  THdfsCompression::type compression;
  int64_t last_modification_time;
  std::vector<THdfsFileBlock>  file_blocks;

  void __set_file_name(const std::string& val) {
    file_name = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_compression(const THdfsCompression::type val) {
    compression = val;
  }

  void __set_last_modification_time(const int64_t val) {
    last_modification_time = val;
  }

  void __set_file_blocks(const std::vector<THdfsFileBlock> & val) {
    file_blocks = val;
  }

  bool operator == (const THdfsFileDesc & rhs) const
  {
    if (!(file_name == rhs.file_name))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(compression == rhs.compression))
      return false;
    if (!(last_modification_time == rhs.last_modification_time))
      return false;
    if (!(file_blocks == rhs.file_blocks))
      return false;
    return true;
  }
  bool operator != (const THdfsFileDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileDesc &a, THdfsFileDesc &b);

typedef struct _THdfsPartition__isset {
  _THdfsPartition__isset() : partitionKeyExprs(false), file_desc(false), location(false), access_level(false), stats(false), is_marked_cached(false), id(false) {}
  bool partitionKeyExprs;
  bool file_desc;
  bool location;
  bool access_level;
  bool stats;
  bool is_marked_cached;
  bool id;
} _THdfsPartition__isset;

class THdfsPartition {
 public:

  static const char* ascii_fingerprint; // = "1DA72198E26835090F1E30F424F81CD3";
  static const uint8_t binary_fingerprint[16]; // = {0x1D,0xA7,0x21,0x98,0xE2,0x68,0x35,0x09,0x0F,0x1E,0x30,0xF4,0x24,0xF8,0x1C,0xD3};

  THdfsPartition() : lineDelim(0), fieldDelim(0), collectionDelim(0), mapKeyDelim(0), escapeChar(0), fileFormat((THdfsFileFormat::type)0), blockSize(0), compression((THdfsCompression::type)0), location(), access_level((TAccessLevel::type)0), is_marked_cached(0), id(0) {
  }

  virtual ~THdfsPartition() throw() {}

  int8_t lineDelim;
  int8_t fieldDelim;
  int8_t collectionDelim;
  int8_t mapKeyDelim;
  int8_t escapeChar;
  THdfsFileFormat::type fileFormat;
  std::vector< ::impala::TExpr>  partitionKeyExprs;
  int32_t blockSize;
  THdfsCompression::type compression;
  std::vector<THdfsFileDesc>  file_desc;
  std::string location;
  TAccessLevel::type access_level;
  TTableStats stats;
  bool is_marked_cached;
  int64_t id;

  _THdfsPartition__isset __isset;

  void __set_lineDelim(const int8_t val) {
    lineDelim = val;
  }

  void __set_fieldDelim(const int8_t val) {
    fieldDelim = val;
  }

  void __set_collectionDelim(const int8_t val) {
    collectionDelim = val;
  }

  void __set_mapKeyDelim(const int8_t val) {
    mapKeyDelim = val;
  }

  void __set_escapeChar(const int8_t val) {
    escapeChar = val;
  }

  void __set_fileFormat(const THdfsFileFormat::type val) {
    fileFormat = val;
  }

  void __set_partitionKeyExprs(const std::vector< ::impala::TExpr> & val) {
    partitionKeyExprs = val;
    __isset.partitionKeyExprs = true;
  }

  void __set_blockSize(const int32_t val) {
    blockSize = val;
  }

  void __set_compression(const THdfsCompression::type val) {
    compression = val;
  }

  void __set_file_desc(const std::vector<THdfsFileDesc> & val) {
    file_desc = val;
    __isset.file_desc = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  void __set_access_level(const TAccessLevel::type val) {
    access_level = val;
    __isset.access_level = true;
  }

  void __set_stats(const TTableStats& val) {
    stats = val;
    __isset.stats = true;
  }

  void __set_is_marked_cached(const bool val) {
    is_marked_cached = val;
    __isset.is_marked_cached = true;
  }

  void __set_id(const int64_t val) {
    id = val;
    __isset.id = true;
  }

  bool operator == (const THdfsPartition & rhs) const
  {
    if (!(lineDelim == rhs.lineDelim))
      return false;
    if (!(fieldDelim == rhs.fieldDelim))
      return false;
    if (!(collectionDelim == rhs.collectionDelim))
      return false;
    if (!(mapKeyDelim == rhs.mapKeyDelim))
      return false;
    if (!(escapeChar == rhs.escapeChar))
      return false;
    if (!(fileFormat == rhs.fileFormat))
      return false;
    if (!(partitionKeyExprs == rhs.partitionKeyExprs))
      return false;
    if (!(blockSize == rhs.blockSize))
      return false;
    if (!(compression == rhs.compression))
      return false;
    if (__isset.file_desc != rhs.__isset.file_desc)
      return false;
    else if (__isset.file_desc && !(file_desc == rhs.file_desc))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.access_level != rhs.__isset.access_level)
      return false;
    else if (__isset.access_level && !(access_level == rhs.access_level))
      return false;
    if (__isset.stats != rhs.__isset.stats)
      return false;
    else if (__isset.stats && !(stats == rhs.stats))
      return false;
    if (__isset.is_marked_cached != rhs.__isset.is_marked_cached)
      return false;
    else if (__isset.is_marked_cached && !(is_marked_cached == rhs.is_marked_cached))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const THdfsPartition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsPartition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsPartition &a, THdfsPartition &b);

typedef struct _THdfsTable__isset {
  _THdfsTable__isset() : avroSchema(false), network_addresses(false) {}
  bool avroSchema;
  bool network_addresses;
} _THdfsTable__isset;

class THdfsTable {
 public:

  static const char* ascii_fingerprint; // = "4EB58FA4A6342FE3033E0CA6F04925D2";
  static const uint8_t binary_fingerprint[16]; // = {0x4E,0xB5,0x8F,0xA4,0xA6,0x34,0x2F,0xE3,0x03,0x3E,0x0C,0xA6,0xF0,0x49,0x25,0xD2};

  THdfsTable() : hdfsBaseDir(), nullPartitionKeyValue(), nullColumnValue(), avroSchema() {
  }

  virtual ~THdfsTable() throw() {}

  std::string hdfsBaseDir;
  std::vector<std::string>  colNames;
  std::string nullPartitionKeyValue;
  std::string nullColumnValue;
  std::string avroSchema;
  std::map<int64_t, THdfsPartition>  partitions;
  std::vector< ::impala::TNetworkAddress>  network_addresses;

  _THdfsTable__isset __isset;

  void __set_hdfsBaseDir(const std::string& val) {
    hdfsBaseDir = val;
  }

  void __set_colNames(const std::vector<std::string> & val) {
    colNames = val;
  }

  void __set_nullPartitionKeyValue(const std::string& val) {
    nullPartitionKeyValue = val;
  }

  void __set_nullColumnValue(const std::string& val) {
    nullColumnValue = val;
  }

  void __set_avroSchema(const std::string& val) {
    avroSchema = val;
    __isset.avroSchema = true;
  }

  void __set_partitions(const std::map<int64_t, THdfsPartition> & val) {
    partitions = val;
  }

  void __set_network_addresses(const std::vector< ::impala::TNetworkAddress> & val) {
    network_addresses = val;
    __isset.network_addresses = true;
  }

  bool operator == (const THdfsTable & rhs) const
  {
    if (!(hdfsBaseDir == rhs.hdfsBaseDir))
      return false;
    if (!(colNames == rhs.colNames))
      return false;
    if (!(nullPartitionKeyValue == rhs.nullPartitionKeyValue))
      return false;
    if (!(nullColumnValue == rhs.nullColumnValue))
      return false;
    if (__isset.avroSchema != rhs.__isset.avroSchema)
      return false;
    else if (__isset.avroSchema && !(avroSchema == rhs.avroSchema))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    if (__isset.network_addresses != rhs.__isset.network_addresses)
      return false;
    else if (__isset.network_addresses && !(network_addresses == rhs.network_addresses))
      return false;
    return true;
  }
  bool operator != (const THdfsTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsTable &a, THdfsTable &b);

typedef struct _THBaseTable__isset {
  _THBaseTable__isset() : binary_encoded(false) {}
  bool binary_encoded;
} _THBaseTable__isset;

class THBaseTable {
 public:

  static const char* ascii_fingerprint; // = "1020D6DBCD4B2FB077A077715FEA851B";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x20,0xD6,0xDB,0xCD,0x4B,0x2F,0xB0,0x77,0xA0,0x77,0x71,0x5F,0xEA,0x85,0x1B};

  THBaseTable() : tableName() {
  }

  virtual ~THBaseTable() throw() {}

  std::string tableName;
  std::vector<std::string>  families;
  std::vector<std::string>  qualifiers;
  std::vector<bool>  binary_encoded;

  _THBaseTable__isset __isset;

  void __set_tableName(const std::string& val) {
    tableName = val;
  }

  void __set_families(const std::vector<std::string> & val) {
    families = val;
  }

  void __set_qualifiers(const std::vector<std::string> & val) {
    qualifiers = val;
  }

  void __set_binary_encoded(const std::vector<bool> & val) {
    binary_encoded = val;
    __isset.binary_encoded = true;
  }

  bool operator == (const THBaseTable & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(families == rhs.families))
      return false;
    if (!(qualifiers == rhs.qualifiers))
      return false;
    if (__isset.binary_encoded != rhs.__isset.binary_encoded)
      return false;
    else if (__isset.binary_encoded && !(binary_encoded == rhs.binary_encoded))
      return false;
    return true;
  }
  bool operator != (const THBaseTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseTable &a, THBaseTable &b);


class TDataSource {
 public:

  static const char* ascii_fingerprint; // = "C93D890311F28844166CF6E571EB3AC2";
  static const uint8_t binary_fingerprint[16]; // = {0xC9,0x3D,0x89,0x03,0x11,0xF2,0x88,0x44,0x16,0x6C,0xF6,0xE5,0x71,0xEB,0x3A,0xC2};

  TDataSource() : name(), hdfs_location(), class_name(), api_version() {
  }

  virtual ~TDataSource() throw() {}

  std::string name;
  std::string hdfs_location;
  std::string class_name;
  std::string api_version;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_hdfs_location(const std::string& val) {
    hdfs_location = val;
  }

  void __set_class_name(const std::string& val) {
    class_name = val;
  }

  void __set_api_version(const std::string& val) {
    api_version = val;
  }

  bool operator == (const TDataSource & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(hdfs_location == rhs.hdfs_location))
      return false;
    if (!(class_name == rhs.class_name))
      return false;
    if (!(api_version == rhs.api_version))
      return false;
    return true;
  }
  bool operator != (const TDataSource &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataSource & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDataSource &a, TDataSource &b);


class TDataSourceTable {
 public:

  static const char* ascii_fingerprint; // = "7ADC8F063F12245EDF20DEB68DBB1D55";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0xDC,0x8F,0x06,0x3F,0x12,0x24,0x5E,0xDF,0x20,0xDE,0xB6,0x8D,0xBB,0x1D,0x55};

  TDataSourceTable() : init_string() {
  }

  virtual ~TDataSourceTable() throw() {}

  TDataSource data_source;
  std::string init_string;

  void __set_data_source(const TDataSource& val) {
    data_source = val;
  }

  void __set_init_string(const std::string& val) {
    init_string = val;
  }

  bool operator == (const TDataSourceTable & rhs) const
  {
    if (!(data_source == rhs.data_source))
      return false;
    if (!(init_string == rhs.init_string))
      return false;
    return true;
  }
  bool operator != (const TDataSourceTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataSourceTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDataSourceTable &a, TDataSourceTable &b);

typedef struct _TTable__isset {
  _TTable__isset() : load_status(false), id(false), access_level(false), columns(false), clustering_columns(false), table_stats(false), table_type(false), hdfs_table(false), hbase_table(false), metastore_table(false), data_source_table(false) {}
  bool load_status;
  bool id;
  bool access_level;
  bool columns;
  bool clustering_columns;
  bool table_stats;
  bool table_type;
  bool hdfs_table;
  bool hbase_table;
  bool metastore_table;
  bool data_source_table;
} _TTable__isset;

class TTable {
 public:

  static const char* ascii_fingerprint; // = "08FC496106DAEA03473EE94174EF2980";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0xFC,0x49,0x61,0x06,0xDA,0xEA,0x03,0x47,0x3E,0xE9,0x41,0x74,0xEF,0x29,0x80};

  TTable() : db_name(), tbl_name(), id(0), access_level((TAccessLevel::type)0), table_type((TTableType::type)0) {
  }

  virtual ~TTable() throw() {}

  std::string db_name;
  std::string tbl_name;
   ::impala::TStatus load_status;
   ::impala::TTableId id;
  TAccessLevel::type access_level;
  std::vector<TColumn>  columns;
  std::vector<TColumn>  clustering_columns;
  TTableStats table_stats;
  TTableType::type table_type;
  THdfsTable hdfs_table;
  THBaseTable hbase_table;
   ::Apache::Hadoop::Hive::Table metastore_table;
  TDataSourceTable data_source_table;

  _TTable__isset __isset;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_tbl_name(const std::string& val) {
    tbl_name = val;
  }

  void __set_load_status(const  ::impala::TStatus& val) {
    load_status = val;
    __isset.load_status = true;
  }

  void __set_id(const  ::impala::TTableId val) {
    id = val;
    __isset.id = true;
  }

  void __set_access_level(const TAccessLevel::type val) {
    access_level = val;
    __isset.access_level = true;
  }

  void __set_columns(const std::vector<TColumn> & val) {
    columns = val;
    __isset.columns = true;
  }

  void __set_clustering_columns(const std::vector<TColumn> & val) {
    clustering_columns = val;
    __isset.clustering_columns = true;
  }

  void __set_table_stats(const TTableStats& val) {
    table_stats = val;
    __isset.table_stats = true;
  }

  void __set_table_type(const TTableType::type val) {
    table_type = val;
    __isset.table_type = true;
  }

  void __set_hdfs_table(const THdfsTable& val) {
    hdfs_table = val;
    __isset.hdfs_table = true;
  }

  void __set_hbase_table(const THBaseTable& val) {
    hbase_table = val;
    __isset.hbase_table = true;
  }

  void __set_metastore_table(const  ::Apache::Hadoop::Hive::Table& val) {
    metastore_table = val;
    __isset.metastore_table = true;
  }

  void __set_data_source_table(const TDataSourceTable& val) {
    data_source_table = val;
    __isset.data_source_table = true;
  }

  bool operator == (const TTable & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (!(tbl_name == rhs.tbl_name))
      return false;
    if (__isset.load_status != rhs.__isset.load_status)
      return false;
    else if (__isset.load_status && !(load_status == rhs.load_status))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.access_level != rhs.__isset.access_level)
      return false;
    else if (__isset.access_level && !(access_level == rhs.access_level))
      return false;
    if (__isset.columns != rhs.__isset.columns)
      return false;
    else if (__isset.columns && !(columns == rhs.columns))
      return false;
    if (__isset.clustering_columns != rhs.__isset.clustering_columns)
      return false;
    else if (__isset.clustering_columns && !(clustering_columns == rhs.clustering_columns))
      return false;
    if (__isset.table_stats != rhs.__isset.table_stats)
      return false;
    else if (__isset.table_stats && !(table_stats == rhs.table_stats))
      return false;
    if (__isset.table_type != rhs.__isset.table_type)
      return false;
    else if (__isset.table_type && !(table_type == rhs.table_type))
      return false;
    if (__isset.hdfs_table != rhs.__isset.hdfs_table)
      return false;
    else if (__isset.hdfs_table && !(hdfs_table == rhs.hdfs_table))
      return false;
    if (__isset.hbase_table != rhs.__isset.hbase_table)
      return false;
    else if (__isset.hbase_table && !(hbase_table == rhs.hbase_table))
      return false;
    if (__isset.metastore_table != rhs.__isset.metastore_table)
      return false;
    else if (__isset.metastore_table && !(metastore_table == rhs.metastore_table))
      return false;
    if (__isset.data_source_table != rhs.__isset.data_source_table)
      return false;
    else if (__isset.data_source_table && !(data_source_table == rhs.data_source_table))
      return false;
    return true;
  }
  bool operator != (const TTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTable &a, TTable &b);

typedef struct _TDatabase__isset {
  _TDatabase__isset() : location(false) {}
  bool location;
} _TDatabase__isset;

class TDatabase {
 public:

  static const char* ascii_fingerprint; // = "5B708A954C550ECA9C1A49D3C5CAFAB9";
  static const uint8_t binary_fingerprint[16]; // = {0x5B,0x70,0x8A,0x95,0x4C,0x55,0x0E,0xCA,0x9C,0x1A,0x49,0xD3,0xC5,0xCA,0xFA,0xB9};

  TDatabase() : db_name(), location() {
  }

  virtual ~TDatabase() throw() {}

  std::string db_name;
  std::string location;

  _TDatabase__isset __isset;

  void __set_db_name(const std::string& val) {
    db_name = val;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const TDatabase & rhs) const
  {
    if (!(db_name == rhs.db_name))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const TDatabase &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDatabase & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDatabase &a, TDatabase &b);


class TRole {
 public:

  static const char* ascii_fingerprint; // = "6AB241362403A4E30F9D3B91873CCEF0";
  static const uint8_t binary_fingerprint[16]; // = {0x6A,0xB2,0x41,0x36,0x24,0x03,0xA4,0xE3,0x0F,0x9D,0x3B,0x91,0x87,0x3C,0xCE,0xF0};

  TRole() : role_name(), role_id(0) {
  }

  virtual ~TRole() throw() {}

  std::string role_name;
  int32_t role_id;
  std::vector<std::string>  grant_groups;

  void __set_role_name(const std::string& val) {
    role_name = val;
  }

  void __set_role_id(const int32_t val) {
    role_id = val;
  }

  void __set_grant_groups(const std::vector<std::string> & val) {
    grant_groups = val;
  }

  bool operator == (const TRole & rhs) const
  {
    if (!(role_name == rhs.role_name))
      return false;
    if (!(role_id == rhs.role_id))
      return false;
    if (!(grant_groups == rhs.grant_groups))
      return false;
    return true;
  }
  bool operator != (const TRole &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRole & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRole &a, TRole &b);


class TPrivilege {
 public:

  static const char* ascii_fingerprint; // = "A0A4DD7B8243FB842E64EAC6E5DA6C7B";
  static const uint8_t binary_fingerprint[16]; // = {0xA0,0xA4,0xDD,0x7B,0x82,0x43,0xFB,0x84,0x2E,0x64,0xEA,0xC6,0xE5,0xDA,0x6C,0x7B};

  TPrivilege() : privilege_name(), scope((TPrivilegeScope::type)0), role_id(0) {
  }

  virtual ~TPrivilege() throw() {}

  std::string privilege_name;
  TPrivilegeScope::type scope;
  int32_t role_id;

  void __set_privilege_name(const std::string& val) {
    privilege_name = val;
  }

  void __set_scope(const TPrivilegeScope::type val) {
    scope = val;
  }

  void __set_role_id(const int32_t val) {
    role_id = val;
  }

  bool operator == (const TPrivilege & rhs) const
  {
    if (!(privilege_name == rhs.privilege_name))
      return false;
    if (!(scope == rhs.scope))
      return false;
    if (!(role_id == rhs.role_id))
      return false;
    return true;
  }
  bool operator != (const TPrivilege &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrivilege & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPrivilege &a, TPrivilege &b);


class THdfsCachePool {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  THdfsCachePool() : pool_name() {
  }

  virtual ~THdfsCachePool() throw() {}

  std::string pool_name;

  void __set_pool_name(const std::string& val) {
    pool_name = val;
  }

  bool operator == (const THdfsCachePool & rhs) const
  {
    if (!(pool_name == rhs.pool_name))
      return false;
    return true;
  }
  bool operator != (const THdfsCachePool &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsCachePool & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsCachePool &a, THdfsCachePool &b);


class TCatalog {
 public:

  static const char* ascii_fingerprint; // = "9CFE4A6581B5B8EB11F5BBBCEFA07940";
  static const uint8_t binary_fingerprint[16]; // = {0x9C,0xFE,0x4A,0x65,0x81,0xB5,0xB8,0xEB,0x11,0xF5,0xBB,0xBC,0xEF,0xA0,0x79,0x40};

  TCatalog() {
  }

  virtual ~TCatalog() throw() {}

   ::impala::TUniqueId catalog_service_id;

  void __set_catalog_service_id(const  ::impala::TUniqueId& val) {
    catalog_service_id = val;
  }

  bool operator == (const TCatalog & rhs) const
  {
    if (!(catalog_service_id == rhs.catalog_service_id))
      return false;
    return true;
  }
  bool operator != (const TCatalog &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCatalog & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCatalog &a, TCatalog &b);

typedef struct _TCatalogObject__isset {
  _TCatalogObject__isset() : catalog(false), db(false), table(false), fn(false), data_source(false), role(false), privilege(false), cache_pool(false) {}
  bool catalog;
  bool db;
  bool table;
  bool fn;
  bool data_source;
  bool role;
  bool privilege;
  bool cache_pool;
} _TCatalogObject__isset;

class TCatalogObject {
 public:

  static const char* ascii_fingerprint; // = "D0AD4E21E2AA076120292B7CE720AA3F";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0xAD,0x4E,0x21,0xE2,0xAA,0x07,0x61,0x20,0x29,0x2B,0x7C,0xE7,0x20,0xAA,0x3F};

  TCatalogObject() : type((TCatalogObjectType::type)0), catalog_version(0) {
  }

  virtual ~TCatalogObject() throw() {}

  TCatalogObjectType::type type;
  int64_t catalog_version;
  TCatalog catalog;
  TDatabase db;
  TTable table;
   ::impala::TFunction fn;
  TDataSource data_source;
  TRole role;
  TPrivilege privilege;
  THdfsCachePool cache_pool;

  _TCatalogObject__isset __isset;

  void __set_type(const TCatalogObjectType::type val) {
    type = val;
  }

  void __set_catalog_version(const int64_t val) {
    catalog_version = val;
  }

  void __set_catalog(const TCatalog& val) {
    catalog = val;
    __isset.catalog = true;
  }

  void __set_db(const TDatabase& val) {
    db = val;
    __isset.db = true;
  }

  void __set_table(const TTable& val) {
    table = val;
    __isset.table = true;
  }

  void __set_fn(const  ::impala::TFunction& val) {
    fn = val;
    __isset.fn = true;
  }

  void __set_data_source(const TDataSource& val) {
    data_source = val;
    __isset.data_source = true;
  }

  void __set_role(const TRole& val) {
    role = val;
    __isset.role = true;
  }

  void __set_privilege(const TPrivilege& val) {
    privilege = val;
    __isset.privilege = true;
  }

  void __set_cache_pool(const THdfsCachePool& val) {
    cache_pool = val;
    __isset.cache_pool = true;
  }

  bool operator == (const TCatalogObject & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(catalog_version == rhs.catalog_version))
      return false;
    if (__isset.catalog != rhs.__isset.catalog)
      return false;
    else if (__isset.catalog && !(catalog == rhs.catalog))
      return false;
    if (__isset.db != rhs.__isset.db)
      return false;
    else if (__isset.db && !(db == rhs.db))
      return false;
    if (__isset.table != rhs.__isset.table)
      return false;
    else if (__isset.table && !(table == rhs.table))
      return false;
    if (__isset.fn != rhs.__isset.fn)
      return false;
    else if (__isset.fn && !(fn == rhs.fn))
      return false;
    if (__isset.data_source != rhs.__isset.data_source)
      return false;
    else if (__isset.data_source && !(data_source == rhs.data_source))
      return false;
    if (__isset.role != rhs.__isset.role)
      return false;
    else if (__isset.role && !(role == rhs.role))
      return false;
    if (__isset.privilege != rhs.__isset.privilege)
      return false;
    else if (__isset.privilege && !(privilege == rhs.privilege))
      return false;
    if (__isset.cache_pool != rhs.__isset.cache_pool)
      return false;
    else if (__isset.cache_pool && !(cache_pool == rhs.cache_pool))
      return false;
    return true;
  }
  bool operator != (const TCatalogObject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCatalogObject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCatalogObject &a, TCatalogObject &b);

} // namespace

#endif
