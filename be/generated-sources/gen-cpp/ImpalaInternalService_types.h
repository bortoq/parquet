/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ImpalaInternalService_TYPES_H
#define ImpalaInternalService_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Status_types.h"
#include "Types_types.h"
#include "Exprs_types.h"
#include "CatalogObjects_types.h"
#include "Descriptors_types.h"
#include "PlanNodes_types.h"
#include "Planner_types.h"
#include "DataSinks_types.h"
#include "Data_types.h"
#include "RuntimeProfile_types.h"
#include "ImpalaService_types.h"
#include "Llama_types.h"


namespace impala {

struct TSessionType {
  enum type {
    BEESWAX = 0,
    HIVESERVER2 = 1
  };
};

extern const std::map<int, const char*> _TSessionType_VALUES_TO_NAMES;

struct ImpalaInternalServiceVersion {
  enum type {
    V1 = 0
  };
};

extern const std::map<int, const char*> _ImpalaInternalServiceVersion_VALUES_TO_NAMES;

typedef struct _TQueryOptions__isset {
  _TQueryOptions__isset() : abort_on_error(true), max_errors(true), disable_codegen(true), batch_size(true), num_nodes(true), max_scan_range_length(true), num_scanner_threads(true), max_io_buffers(true), allow_unsupported_formats(true), default_order_by_limit(true), debug_action(true), mem_limit(true), abort_on_default_limit_exceeded(true), parquet_compression_codec(true), hbase_caching(true), hbase_cache_blocks(true), parquet_file_size(true), explain_level(false), sync_ddl(true), request_pool(false), v_cpu_cores(false), reservation_request_timeout(false), disable_cached_reads(true), disable_outermost_topn(true) {}
  bool abort_on_error;
  bool max_errors;
  bool disable_codegen;
  bool batch_size;
  bool num_nodes;
  bool max_scan_range_length;
  bool num_scanner_threads;
  bool max_io_buffers;
  bool allow_unsupported_formats;
  bool default_order_by_limit;
  bool debug_action;
  bool mem_limit;
  bool abort_on_default_limit_exceeded;
  bool parquet_compression_codec;
  bool hbase_caching;
  bool hbase_cache_blocks;
  bool parquet_file_size;
  bool explain_level;
  bool sync_ddl;
  bool request_pool;
  bool v_cpu_cores;
  bool reservation_request_timeout;
  bool disable_cached_reads;
  bool disable_outermost_topn;
} _TQueryOptions__isset;

class TQueryOptions {
 public:

  static const char* ascii_fingerprint; // = "444B9AA7744B10A065147607B6B5ECC6";
  static const uint8_t binary_fingerprint[16]; // = {0x44,0x4B,0x9A,0xA7,0x74,0x4B,0x10,0xA0,0x65,0x14,0x76,0x07,0xB6,0xB5,0xEC,0xC6};

  TQueryOptions() : abort_on_error(false), max_errors(0), disable_codegen(false), batch_size(0), num_nodes(0), max_scan_range_length(0LL), num_scanner_threads(0), max_io_buffers(0), allow_unsupported_formats(false), default_order_by_limit(-1LL), debug_action(""), mem_limit(0LL), abort_on_default_limit_exceeded(false), parquet_compression_codec(( ::impala::THdfsCompression::type)5), hbase_caching(0), hbase_cache_blocks(false), parquet_file_size(0LL), explain_level(( ::impala::TExplainLevel::type)0), sync_ddl(false), request_pool(), v_cpu_cores(0), reservation_request_timeout(0), disable_cached_reads(false), disable_outermost_topn(false) {
    parquet_compression_codec = ( ::impala::THdfsCompression::type)5;

  }

  virtual ~TQueryOptions() throw() {}

  bool abort_on_error;
  int32_t max_errors;
  bool disable_codegen;
  int32_t batch_size;
  int32_t num_nodes;
  int64_t max_scan_range_length;
  int32_t num_scanner_threads;
  int32_t max_io_buffers;
  bool allow_unsupported_formats;
  int64_t default_order_by_limit;
  std::string debug_action;
  int64_t mem_limit;
  bool abort_on_default_limit_exceeded;
   ::impala::THdfsCompression::type parquet_compression_codec;
  int32_t hbase_caching;
  bool hbase_cache_blocks;
  int64_t parquet_file_size;
   ::impala::TExplainLevel::type explain_level;
  bool sync_ddl;
  std::string request_pool;
  int16_t v_cpu_cores;
  int64_t reservation_request_timeout;
  bool disable_cached_reads;
  bool disable_outermost_topn;

  _TQueryOptions__isset __isset;

  void __set_abort_on_error(const bool val) {
    abort_on_error = val;
    __isset.abort_on_error = true;
  }

  void __set_max_errors(const int32_t val) {
    max_errors = val;
    __isset.max_errors = true;
  }

  void __set_disable_codegen(const bool val) {
    disable_codegen = val;
    __isset.disable_codegen = true;
  }

  void __set_batch_size(const int32_t val) {
    batch_size = val;
    __isset.batch_size = true;
  }

  void __set_num_nodes(const int32_t val) {
    num_nodes = val;
    __isset.num_nodes = true;
  }

  void __set_max_scan_range_length(const int64_t val) {
    max_scan_range_length = val;
    __isset.max_scan_range_length = true;
  }

  void __set_num_scanner_threads(const int32_t val) {
    num_scanner_threads = val;
    __isset.num_scanner_threads = true;
  }

  void __set_max_io_buffers(const int32_t val) {
    max_io_buffers = val;
    __isset.max_io_buffers = true;
  }

  void __set_allow_unsupported_formats(const bool val) {
    allow_unsupported_formats = val;
    __isset.allow_unsupported_formats = true;
  }

  void __set_default_order_by_limit(const int64_t val) {
    default_order_by_limit = val;
    __isset.default_order_by_limit = true;
  }

  void __set_debug_action(const std::string& val) {
    debug_action = val;
    __isset.debug_action = true;
  }

  void __set_mem_limit(const int64_t val) {
    mem_limit = val;
    __isset.mem_limit = true;
  }

  void __set_abort_on_default_limit_exceeded(const bool val) {
    abort_on_default_limit_exceeded = val;
    __isset.abort_on_default_limit_exceeded = true;
  }

  void __set_parquet_compression_codec(const  ::impala::THdfsCompression::type val) {
    parquet_compression_codec = val;
    __isset.parquet_compression_codec = true;
  }

  void __set_hbase_caching(const int32_t val) {
    hbase_caching = val;
    __isset.hbase_caching = true;
  }

  void __set_hbase_cache_blocks(const bool val) {
    hbase_cache_blocks = val;
    __isset.hbase_cache_blocks = true;
  }

  void __set_parquet_file_size(const int64_t val) {
    parquet_file_size = val;
    __isset.parquet_file_size = true;
  }

  void __set_explain_level(const  ::impala::TExplainLevel::type val) {
    explain_level = val;
    __isset.explain_level = true;
  }

  void __set_sync_ddl(const bool val) {
    sync_ddl = val;
    __isset.sync_ddl = true;
  }

  void __set_request_pool(const std::string& val) {
    request_pool = val;
    __isset.request_pool = true;
  }

  void __set_v_cpu_cores(const int16_t val) {
    v_cpu_cores = val;
    __isset.v_cpu_cores = true;
  }

  void __set_reservation_request_timeout(const int64_t val) {
    reservation_request_timeout = val;
    __isset.reservation_request_timeout = true;
  }

  void __set_disable_cached_reads(const bool val) {
    disable_cached_reads = val;
    __isset.disable_cached_reads = true;
  }

  void __set_disable_outermost_topn(const bool val) {
    disable_outermost_topn = val;
    __isset.disable_outermost_topn = true;
  }

  bool operator == (const TQueryOptions & rhs) const
  {
    if (__isset.abort_on_error != rhs.__isset.abort_on_error)
      return false;
    else if (__isset.abort_on_error && !(abort_on_error == rhs.abort_on_error))
      return false;
    if (__isset.max_errors != rhs.__isset.max_errors)
      return false;
    else if (__isset.max_errors && !(max_errors == rhs.max_errors))
      return false;
    if (__isset.disable_codegen != rhs.__isset.disable_codegen)
      return false;
    else if (__isset.disable_codegen && !(disable_codegen == rhs.disable_codegen))
      return false;
    if (__isset.batch_size != rhs.__isset.batch_size)
      return false;
    else if (__isset.batch_size && !(batch_size == rhs.batch_size))
      return false;
    if (__isset.num_nodes != rhs.__isset.num_nodes)
      return false;
    else if (__isset.num_nodes && !(num_nodes == rhs.num_nodes))
      return false;
    if (__isset.max_scan_range_length != rhs.__isset.max_scan_range_length)
      return false;
    else if (__isset.max_scan_range_length && !(max_scan_range_length == rhs.max_scan_range_length))
      return false;
    if (__isset.num_scanner_threads != rhs.__isset.num_scanner_threads)
      return false;
    else if (__isset.num_scanner_threads && !(num_scanner_threads == rhs.num_scanner_threads))
      return false;
    if (__isset.max_io_buffers != rhs.__isset.max_io_buffers)
      return false;
    else if (__isset.max_io_buffers && !(max_io_buffers == rhs.max_io_buffers))
      return false;
    if (__isset.allow_unsupported_formats != rhs.__isset.allow_unsupported_formats)
      return false;
    else if (__isset.allow_unsupported_formats && !(allow_unsupported_formats == rhs.allow_unsupported_formats))
      return false;
    if (__isset.default_order_by_limit != rhs.__isset.default_order_by_limit)
      return false;
    else if (__isset.default_order_by_limit && !(default_order_by_limit == rhs.default_order_by_limit))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.mem_limit != rhs.__isset.mem_limit)
      return false;
    else if (__isset.mem_limit && !(mem_limit == rhs.mem_limit))
      return false;
    if (__isset.abort_on_default_limit_exceeded != rhs.__isset.abort_on_default_limit_exceeded)
      return false;
    else if (__isset.abort_on_default_limit_exceeded && !(abort_on_default_limit_exceeded == rhs.abort_on_default_limit_exceeded))
      return false;
    if (__isset.parquet_compression_codec != rhs.__isset.parquet_compression_codec)
      return false;
    else if (__isset.parquet_compression_codec && !(parquet_compression_codec == rhs.parquet_compression_codec))
      return false;
    if (__isset.hbase_caching != rhs.__isset.hbase_caching)
      return false;
    else if (__isset.hbase_caching && !(hbase_caching == rhs.hbase_caching))
      return false;
    if (__isset.hbase_cache_blocks != rhs.__isset.hbase_cache_blocks)
      return false;
    else if (__isset.hbase_cache_blocks && !(hbase_cache_blocks == rhs.hbase_cache_blocks))
      return false;
    if (__isset.parquet_file_size != rhs.__isset.parquet_file_size)
      return false;
    else if (__isset.parquet_file_size && !(parquet_file_size == rhs.parquet_file_size))
      return false;
    if (__isset.explain_level != rhs.__isset.explain_level)
      return false;
    else if (__isset.explain_level && !(explain_level == rhs.explain_level))
      return false;
    if (__isset.sync_ddl != rhs.__isset.sync_ddl)
      return false;
    else if (__isset.sync_ddl && !(sync_ddl == rhs.sync_ddl))
      return false;
    if (__isset.request_pool != rhs.__isset.request_pool)
      return false;
    else if (__isset.request_pool && !(request_pool == rhs.request_pool))
      return false;
    if (__isset.v_cpu_cores != rhs.__isset.v_cpu_cores)
      return false;
    else if (__isset.v_cpu_cores && !(v_cpu_cores == rhs.v_cpu_cores))
      return false;
    if (__isset.reservation_request_timeout != rhs.__isset.reservation_request_timeout)
      return false;
    else if (__isset.reservation_request_timeout && !(reservation_request_timeout == rhs.reservation_request_timeout))
      return false;
    if (__isset.disable_cached_reads != rhs.__isset.disable_cached_reads)
      return false;
    else if (__isset.disable_cached_reads && !(disable_cached_reads == rhs.disable_cached_reads))
      return false;
    if (__isset.disable_outermost_topn != rhs.__isset.disable_outermost_topn)
      return false;
    else if (__isset.disable_outermost_topn && !(disable_outermost_topn == rhs.disable_outermost_topn))
      return false;
    return true;
  }
  bool operator != (const TQueryOptions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryOptions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryOptions &a, TQueryOptions &b);

typedef struct _TSessionState__isset {
  _TSessionState__isset() : impersonated_user(false) {}
  bool impersonated_user;
} _TSessionState__isset;

class TSessionState {
 public:

  static const char* ascii_fingerprint; // = "03ABA27DC8B6708FEAF673448A0FA1E6";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0xAB,0xA2,0x7D,0xC8,0xB6,0x70,0x8F,0xEA,0xF6,0x73,0x44,0x8A,0x0F,0xA1,0xE6};

  TSessionState() : session_type((TSessionType::type)0), database(), connected_user(), impersonated_user() {
  }

  virtual ~TSessionState() throw() {}

   ::impala::TUniqueId session_id;
  TSessionType::type session_type;
  std::string database;
  std::string connected_user;
  std::string impersonated_user;
   ::impala::TNetworkAddress network_address;

  _TSessionState__isset __isset;

  void __set_session_id(const  ::impala::TUniqueId& val) {
    session_id = val;
  }

  void __set_session_type(const TSessionType::type val) {
    session_type = val;
  }

  void __set_database(const std::string& val) {
    database = val;
  }

  void __set_connected_user(const std::string& val) {
    connected_user = val;
  }

  void __set_impersonated_user(const std::string& val) {
    impersonated_user = val;
    __isset.impersonated_user = true;
  }

  void __set_network_address(const  ::impala::TNetworkAddress& val) {
    network_address = val;
  }

  bool operator == (const TSessionState & rhs) const
  {
    if (!(session_id == rhs.session_id))
      return false;
    if (!(session_type == rhs.session_type))
      return false;
    if (!(database == rhs.database))
      return false;
    if (!(connected_user == rhs.connected_user))
      return false;
    if (__isset.impersonated_user != rhs.__isset.impersonated_user)
      return false;
    else if (__isset.impersonated_user && !(impersonated_user == rhs.impersonated_user))
      return false;
    if (!(network_address == rhs.network_address))
      return false;
    return true;
  }
  bool operator != (const TSessionState &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSessionState & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSessionState &a, TSessionState &b);


class TClientRequest {
 public:

  static const char* ascii_fingerprint; // = "2A49D867782AF7DEC5354E285EA00132";
  static const uint8_t binary_fingerprint[16]; // = {0x2A,0x49,0xD8,0x67,0x78,0x2A,0xF7,0xDE,0xC5,0x35,0x4E,0x28,0x5E,0xA0,0x01,0x32};

  TClientRequest() : stmt() {
  }

  virtual ~TClientRequest() throw() {}

  std::string stmt;
  TQueryOptions query_options;

  void __set_stmt(const std::string& val) {
    stmt = val;
  }

  void __set_query_options(const TQueryOptions& val) {
    query_options = val;
  }

  bool operator == (const TClientRequest & rhs) const
  {
    if (!(stmt == rhs.stmt))
      return false;
    if (!(query_options == rhs.query_options))
      return false;
    return true;
  }
  bool operator != (const TClientRequest &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TClientRequest & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TClientRequest &a, TClientRequest &b);

typedef struct _TQueryCtx__isset {
  _TQueryCtx__isset() : coord_address(false), tables_missing_stats(false) {}
  bool coord_address;
  bool tables_missing_stats;
} _TQueryCtx__isset;

class TQueryCtx {
 public:

  static const char* ascii_fingerprint; // = "BF8D15DA8BC17223F7FB803B0E13AD49";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x8D,0x15,0xDA,0x8B,0xC1,0x72,0x23,0xF7,0xFB,0x80,0x3B,0x0E,0x13,0xAD,0x49};

  TQueryCtx() : now_string(), pid(0) {
  }

  virtual ~TQueryCtx() throw() {}

  TClientRequest request;
   ::impala::TUniqueId query_id;
  TSessionState session;
  std::string now_string;
  int32_t pid;
   ::impala::TNetworkAddress coord_address;
  std::vector< ::impala::TTableName>  tables_missing_stats;

  _TQueryCtx__isset __isset;

  void __set_request(const TClientRequest& val) {
    request = val;
  }

  void __set_query_id(const  ::impala::TUniqueId& val) {
    query_id = val;
  }

  void __set_session(const TSessionState& val) {
    session = val;
  }

  void __set_now_string(const std::string& val) {
    now_string = val;
  }

  void __set_pid(const int32_t val) {
    pid = val;
  }

  void __set_coord_address(const  ::impala::TNetworkAddress& val) {
    coord_address = val;
    __isset.coord_address = true;
  }

  void __set_tables_missing_stats(const std::vector< ::impala::TTableName> & val) {
    tables_missing_stats = val;
    __isset.tables_missing_stats = true;
  }

  bool operator == (const TQueryCtx & rhs) const
  {
    if (!(request == rhs.request))
      return false;
    if (!(query_id == rhs.query_id))
      return false;
    if (!(session == rhs.session))
      return false;
    if (!(now_string == rhs.now_string))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (__isset.coord_address != rhs.__isset.coord_address)
      return false;
    else if (__isset.coord_address && !(coord_address == rhs.coord_address))
      return false;
    if (__isset.tables_missing_stats != rhs.__isset.tables_missing_stats)
      return false;
    else if (__isset.tables_missing_stats && !(tables_missing_stats == rhs.tables_missing_stats))
      return false;
    return true;
  }
  bool operator != (const TQueryCtx &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TQueryCtx & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TQueryCtx &a, TQueryCtx &b);


class TPlanFragmentInstanceCtx {
 public:

  static const char* ascii_fingerprint; // = "F331F686584FBAF0A80B83AC1BC0D558";
  static const uint8_t binary_fingerprint[16]; // = {0xF3,0x31,0xF6,0x86,0x58,0x4F,0xBA,0xF0,0xA8,0x0B,0x83,0xAC,0x1B,0xC0,0xD5,0x58};

  TPlanFragmentInstanceCtx() : fragment_instance_idx(0), num_fragment_instances(0), backend_num(0) {
  }

  virtual ~TPlanFragmentInstanceCtx() throw() {}

  TQueryCtx query_ctx;
   ::impala::TUniqueId fragment_instance_id;
  int32_t fragment_instance_idx;
  int32_t num_fragment_instances;
  int32_t backend_num;

  void __set_query_ctx(const TQueryCtx& val) {
    query_ctx = val;
  }

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
  }

  void __set_fragment_instance_idx(const int32_t val) {
    fragment_instance_idx = val;
  }

  void __set_num_fragment_instances(const int32_t val) {
    num_fragment_instances = val;
  }

  void __set_backend_num(const int32_t val) {
    backend_num = val;
  }

  bool operator == (const TPlanFragmentInstanceCtx & rhs) const
  {
    if (!(query_ctx == rhs.query_ctx))
      return false;
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(fragment_instance_idx == rhs.fragment_instance_idx))
      return false;
    if (!(num_fragment_instances == rhs.num_fragment_instances))
      return false;
    if (!(backend_num == rhs.backend_num))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentInstanceCtx &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentInstanceCtx & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentInstanceCtx &a, TPlanFragmentInstanceCtx &b);

typedef struct _TScanRangeParams__isset {
  _TScanRangeParams__isset() : volume_id(true), is_cached(true) {}
  bool volume_id;
  bool is_cached;
} _TScanRangeParams__isset;

class TScanRangeParams {
 public:

  static const char* ascii_fingerprint; // = "BC2A4A913F005E32AEA649EB27F079C6";
  static const uint8_t binary_fingerprint[16]; // = {0xBC,0x2A,0x4A,0x91,0x3F,0x00,0x5E,0x32,0xAE,0xA6,0x49,0xEB,0x27,0xF0,0x79,0xC6};

  TScanRangeParams() : volume_id(-1), is_cached(false) {
  }

  virtual ~TScanRangeParams() throw() {}

   ::impala::TScanRange scan_range;
  int32_t volume_id;
  bool is_cached;

  _TScanRangeParams__isset __isset;

  void __set_scan_range(const  ::impala::TScanRange& val) {
    scan_range = val;
  }

  void __set_volume_id(const int32_t val) {
    volume_id = val;
    __isset.volume_id = true;
  }

  void __set_is_cached(const bool val) {
    is_cached = val;
    __isset.is_cached = true;
  }

  bool operator == (const TScanRangeParams & rhs) const
  {
    if (!(scan_range == rhs.scan_range))
      return false;
    if (__isset.volume_id != rhs.__isset.volume_id)
      return false;
    else if (__isset.volume_id && !(volume_id == rhs.volume_id))
      return false;
    if (__isset.is_cached != rhs.__isset.is_cached)
      return false;
    else if (__isset.is_cached && !(is_cached == rhs.is_cached))
      return false;
    return true;
  }
  bool operator != (const TScanRangeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRangeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScanRangeParams &a, TScanRangeParams &b);


class TPlanFragmentDestination {
 public:

  static const char* ascii_fingerprint; // = "2051EF3AC86CAA635A348C806F3F3AE0";
  static const uint8_t binary_fingerprint[16]; // = {0x20,0x51,0xEF,0x3A,0xC8,0x6C,0xAA,0x63,0x5A,0x34,0x8C,0x80,0x6F,0x3F,0x3A,0xE0};

  TPlanFragmentDestination() {
  }

  virtual ~TPlanFragmentDestination() throw() {}

   ::impala::TUniqueId fragment_instance_id;
   ::impala::TNetworkAddress server;

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
  }

  void __set_server(const  ::impala::TNetworkAddress& val) {
    server = val;
  }

  bool operator == (const TPlanFragmentDestination & rhs) const
  {
    if (!(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (!(server == rhs.server))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentDestination &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentDestination & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentDestination &a, TPlanFragmentDestination &b);

typedef struct _TPlanFragmentExecParams__isset {
  _TPlanFragmentExecParams__isset() : destinations(false), debug_node_id(false), debug_phase(false), debug_action(false), request_pool(false), sender_id(false) {}
  bool destinations;
  bool debug_node_id;
  bool debug_phase;
  bool debug_action;
  bool request_pool;
  bool sender_id;
} _TPlanFragmentExecParams__isset;

class TPlanFragmentExecParams {
 public:

  static const char* ascii_fingerprint; // = "7A02FA4B8C068A937AEE06E83CACB7AE";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x02,0xFA,0x4B,0x8C,0x06,0x8A,0x93,0x7A,0xEE,0x06,0xE8,0x3C,0xAC,0xB7,0xAE};

  TPlanFragmentExecParams() : debug_node_id(0), debug_phase(( ::impala::TExecNodePhase::type)0), debug_action(( ::impala::TDebugAction::type)0), request_pool(), sender_id(0) {
  }

  virtual ~TPlanFragmentExecParams() throw() {}

  std::map< ::impala::TPlanNodeId, std::vector<TScanRangeParams> >  per_node_scan_ranges;
  std::map< ::impala::TPlanNodeId, int32_t>  per_exch_num_senders;
  std::vector<TPlanFragmentDestination>  destinations;
   ::impala::TPlanNodeId debug_node_id;
   ::impala::TExecNodePhase::type debug_phase;
   ::impala::TDebugAction::type debug_action;
  std::string request_pool;
  int32_t sender_id;

  _TPlanFragmentExecParams__isset __isset;

  void __set_per_node_scan_ranges(const std::map< ::impala::TPlanNodeId, std::vector<TScanRangeParams> > & val) {
    per_node_scan_ranges = val;
  }

  void __set_per_exch_num_senders(const std::map< ::impala::TPlanNodeId, int32_t> & val) {
    per_exch_num_senders = val;
  }

  void __set_destinations(const std::vector<TPlanFragmentDestination> & val) {
    destinations = val;
    __isset.destinations = true;
  }

  void __set_debug_node_id(const  ::impala::TPlanNodeId val) {
    debug_node_id = val;
    __isset.debug_node_id = true;
  }

  void __set_debug_phase(const  ::impala::TExecNodePhase::type val) {
    debug_phase = val;
    __isset.debug_phase = true;
  }

  void __set_debug_action(const  ::impala::TDebugAction::type val) {
    debug_action = val;
    __isset.debug_action = true;
  }

  void __set_request_pool(const std::string& val) {
    request_pool = val;
    __isset.request_pool = true;
  }

  void __set_sender_id(const int32_t val) {
    sender_id = val;
    __isset.sender_id = true;
  }

  bool operator == (const TPlanFragmentExecParams & rhs) const
  {
    if (!(per_node_scan_ranges == rhs.per_node_scan_ranges))
      return false;
    if (!(per_exch_num_senders == rhs.per_exch_num_senders))
      return false;
    if (!(destinations == rhs.destinations))
      return false;
    if (__isset.debug_node_id != rhs.__isset.debug_node_id)
      return false;
    else if (__isset.debug_node_id && !(debug_node_id == rhs.debug_node_id))
      return false;
    if (__isset.debug_phase != rhs.__isset.debug_phase)
      return false;
    else if (__isset.debug_phase && !(debug_phase == rhs.debug_phase))
      return false;
    if (__isset.debug_action != rhs.__isset.debug_action)
      return false;
    else if (__isset.debug_action && !(debug_action == rhs.debug_action))
      return false;
    if (__isset.request_pool != rhs.__isset.request_pool)
      return false;
    else if (__isset.request_pool && !(request_pool == rhs.request_pool))
      return false;
    if (__isset.sender_id != rhs.__isset.sender_id)
      return false;
    else if (__isset.sender_id && !(sender_id == rhs.sender_id))
      return false;
    return true;
  }
  bool operator != (const TPlanFragmentExecParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanFragmentExecParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanFragmentExecParams &a, TPlanFragmentExecParams &b);

typedef struct _TExecPlanFragmentParams__isset {
  _TExecPlanFragmentParams__isset() : fragment(false), desc_tbl(false), params(false), fragment_instance_ctx(false), reserved_resource(false), local_resource_address(false) {}
  bool fragment;
  bool desc_tbl;
  bool params;
  bool fragment_instance_ctx;
  bool reserved_resource;
  bool local_resource_address;
} _TExecPlanFragmentParams__isset;

class TExecPlanFragmentParams {
 public:

  static const char* ascii_fingerprint; // = "CD6FBB1E9EB74604E693CAB62C4F1230";
  static const uint8_t binary_fingerprint[16]; // = {0xCD,0x6F,0xBB,0x1E,0x9E,0xB7,0x46,0x04,0xE6,0x93,0xCA,0xB6,0x2C,0x4F,0x12,0x30};

  TExecPlanFragmentParams() : protocol_version((ImpalaInternalServiceVersion::type)0) {
  }

  virtual ~TExecPlanFragmentParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TPlanFragment fragment;
   ::impala::TDescriptorTable desc_tbl;
  TPlanFragmentExecParams params;
  TPlanFragmentInstanceCtx fragment_instance_ctx;
   ::llama::TAllocatedResource reserved_resource;
   ::impala::TNetworkAddress local_resource_address;

  _TExecPlanFragmentParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment(const  ::impala::TPlanFragment& val) {
    fragment = val;
    __isset.fragment = true;
  }

  void __set_desc_tbl(const  ::impala::TDescriptorTable& val) {
    desc_tbl = val;
    __isset.desc_tbl = true;
  }

  void __set_params(const TPlanFragmentExecParams& val) {
    params = val;
    __isset.params = true;
  }

  void __set_fragment_instance_ctx(const TPlanFragmentInstanceCtx& val) {
    fragment_instance_ctx = val;
    __isset.fragment_instance_ctx = true;
  }

  void __set_reserved_resource(const  ::llama::TAllocatedResource& val) {
    reserved_resource = val;
    __isset.reserved_resource = true;
  }

  void __set_local_resource_address(const  ::impala::TNetworkAddress& val) {
    local_resource_address = val;
    __isset.local_resource_address = true;
  }

  bool operator == (const TExecPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment != rhs.__isset.fragment)
      return false;
    else if (__isset.fragment && !(fragment == rhs.fragment))
      return false;
    if (__isset.desc_tbl != rhs.__isset.desc_tbl)
      return false;
    else if (__isset.desc_tbl && !(desc_tbl == rhs.desc_tbl))
      return false;
    if (__isset.params != rhs.__isset.params)
      return false;
    else if (__isset.params && !(params == rhs.params))
      return false;
    if (__isset.fragment_instance_ctx != rhs.__isset.fragment_instance_ctx)
      return false;
    else if (__isset.fragment_instance_ctx && !(fragment_instance_ctx == rhs.fragment_instance_ctx))
      return false;
    if (__isset.reserved_resource != rhs.__isset.reserved_resource)
      return false;
    else if (__isset.reserved_resource && !(reserved_resource == rhs.reserved_resource))
      return false;
    if (__isset.local_resource_address != rhs.__isset.local_resource_address)
      return false;
    else if (__isset.local_resource_address && !(local_resource_address == rhs.local_resource_address))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecPlanFragmentParams &a, TExecPlanFragmentParams &b);

typedef struct _TExecPlanFragmentResult__isset {
  _TExecPlanFragmentResult__isset() : status(false) {}
  bool status;
} _TExecPlanFragmentResult__isset;

class TExecPlanFragmentResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TExecPlanFragmentResult() {
  }

  virtual ~TExecPlanFragmentResult() throw() {}

   ::impala::TStatus status;

  _TExecPlanFragmentResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TExecPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TExecPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExecPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExecPlanFragmentResult &a, TExecPlanFragmentResult &b);


class TParquetInsertStats {
 public:

  static const char* ascii_fingerprint; // = "AED0FF6457343172D8ADAA9756E1239C";
  static const uint8_t binary_fingerprint[16]; // = {0xAE,0xD0,0xFF,0x64,0x57,0x34,0x31,0x72,0xD8,0xAD,0xAA,0x97,0x56,0xE1,0x23,0x9C};

  TParquetInsertStats() {
  }

  virtual ~TParquetInsertStats() throw() {}

  std::map<std::string, int64_t>  per_column_size;

  void __set_per_column_size(const std::map<std::string, int64_t> & val) {
    per_column_size = val;
  }

  bool operator == (const TParquetInsertStats & rhs) const
  {
    if (!(per_column_size == rhs.per_column_size))
      return false;
    return true;
  }
  bool operator != (const TParquetInsertStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TParquetInsertStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TParquetInsertStats &a, TParquetInsertStats &b);

typedef struct _TInsertStats__isset {
  _TInsertStats__isset() : parquet_stats(false) {}
  bool parquet_stats;
} _TInsertStats__isset;

class TInsertStats {
 public:

  static const char* ascii_fingerprint; // = "53F717305D4FCC59316DBC84C3BA0B05";
  static const uint8_t binary_fingerprint[16]; // = {0x53,0xF7,0x17,0x30,0x5D,0x4F,0xCC,0x59,0x31,0x6D,0xBC,0x84,0xC3,0xBA,0x0B,0x05};

  TInsertStats() : bytes_written(0) {
  }

  virtual ~TInsertStats() throw() {}

  int64_t bytes_written;
  TParquetInsertStats parquet_stats;

  _TInsertStats__isset __isset;

  void __set_bytes_written(const int64_t val) {
    bytes_written = val;
  }

  void __set_parquet_stats(const TParquetInsertStats& val) {
    parquet_stats = val;
    __isset.parquet_stats = true;
  }

  bool operator == (const TInsertStats & rhs) const
  {
    if (!(bytes_written == rhs.bytes_written))
      return false;
    if (__isset.parquet_stats != rhs.__isset.parquet_stats)
      return false;
    else if (__isset.parquet_stats && !(parquet_stats == rhs.parquet_stats))
      return false;
    return true;
  }
  bool operator != (const TInsertStats &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInsertStats & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInsertStats &a, TInsertStats &b);

typedef struct _TInsertPartitionStatus__isset {
  _TInsertPartitionStatus__isset() : id(false), num_appended_rows(false), stats(false) {}
  bool id;
  bool num_appended_rows;
  bool stats;
} _TInsertPartitionStatus__isset;

class TInsertPartitionStatus {
 public:

  static const char* ascii_fingerprint; // = "84E808CCE9CA7E7A466A3B4A6603BE93";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0xE8,0x08,0xCC,0xE9,0xCA,0x7E,0x7A,0x46,0x6A,0x3B,0x4A,0x66,0x03,0xBE,0x93};

  TInsertPartitionStatus() : id(0), num_appended_rows(0) {
  }

  virtual ~TInsertPartitionStatus() throw() {}

  int64_t id;
  int64_t num_appended_rows;
  TInsertStats stats;

  _TInsertPartitionStatus__isset __isset;

  void __set_id(const int64_t val) {
    id = val;
    __isset.id = true;
  }

  void __set_num_appended_rows(const int64_t val) {
    num_appended_rows = val;
    __isset.num_appended_rows = true;
  }

  void __set_stats(const TInsertStats& val) {
    stats = val;
    __isset.stats = true;
  }

  bool operator == (const TInsertPartitionStatus & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.num_appended_rows != rhs.__isset.num_appended_rows)
      return false;
    else if (__isset.num_appended_rows && !(num_appended_rows == rhs.num_appended_rows))
      return false;
    if (__isset.stats != rhs.__isset.stats)
      return false;
    else if (__isset.stats && !(stats == rhs.stats))
      return false;
    return true;
  }
  bool operator != (const TInsertPartitionStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInsertPartitionStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInsertPartitionStatus &a, TInsertPartitionStatus &b);

typedef struct _TInsertExecStatus__isset {
  _TInsertExecStatus__isset() : per_partition_status(false) {}
  bool per_partition_status;
} _TInsertExecStatus__isset;

class TInsertExecStatus {
 public:

  static const char* ascii_fingerprint; // = "1860026120CFEC4EA2386B191C849E28";
  static const uint8_t binary_fingerprint[16]; // = {0x18,0x60,0x02,0x61,0x20,0xCF,0xEC,0x4E,0xA2,0x38,0x6B,0x19,0x1C,0x84,0x9E,0x28};

  TInsertExecStatus() {
  }

  virtual ~TInsertExecStatus() throw() {}

  std::map<std::string, std::string>  files_to_move;
  std::map<std::string, TInsertPartitionStatus>  per_partition_status;

  _TInsertExecStatus__isset __isset;

  void __set_files_to_move(const std::map<std::string, std::string> & val) {
    files_to_move = val;
  }

  void __set_per_partition_status(const std::map<std::string, TInsertPartitionStatus> & val) {
    per_partition_status = val;
    __isset.per_partition_status = true;
  }

  bool operator == (const TInsertExecStatus & rhs) const
  {
    if (!(files_to_move == rhs.files_to_move))
      return false;
    if (__isset.per_partition_status != rhs.__isset.per_partition_status)
      return false;
    else if (__isset.per_partition_status && !(per_partition_status == rhs.per_partition_status))
      return false;
    return true;
  }
  bool operator != (const TInsertExecStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TInsertExecStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TInsertExecStatus &a, TInsertExecStatus &b);

typedef struct _TReportExecStatusParams__isset {
  _TReportExecStatusParams__isset() : query_id(false), backend_num(false), fragment_instance_id(false), status(false), done(false), profile(false), insert_exec_status(false), error_log(false) {}
  bool query_id;
  bool backend_num;
  bool fragment_instance_id;
  bool status;
  bool done;
  bool profile;
  bool insert_exec_status;
  bool error_log;
} _TReportExecStatusParams__isset;

class TReportExecStatusParams {
 public:

  static const char* ascii_fingerprint; // = "E61DAC0D211222A7386D8017BF17AC1F";
  static const uint8_t binary_fingerprint[16]; // = {0xE6,0x1D,0xAC,0x0D,0x21,0x12,0x22,0xA7,0x38,0x6D,0x80,0x17,0xBF,0x17,0xAC,0x1F};

  TReportExecStatusParams() : protocol_version((ImpalaInternalServiceVersion::type)0), backend_num(0), done(0) {
  }

  virtual ~TReportExecStatusParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TUniqueId query_id;
  int32_t backend_num;
   ::impala::TUniqueId fragment_instance_id;
   ::impala::TStatus status;
  bool done;
   ::impala::TRuntimeProfileTree profile;
  TInsertExecStatus insert_exec_status;
  std::vector<std::string>  error_log;

  _TReportExecStatusParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_query_id(const  ::impala::TUniqueId& val) {
    query_id = val;
    __isset.query_id = true;
  }

  void __set_backend_num(const int32_t val) {
    backend_num = val;
    __isset.backend_num = true;
  }

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
    __isset.fragment_instance_id = true;
  }

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  void __set_done(const bool val) {
    done = val;
    __isset.done = true;
  }

  void __set_profile(const  ::impala::TRuntimeProfileTree& val) {
    profile = val;
    __isset.profile = true;
  }

  void __set_insert_exec_status(const TInsertExecStatus& val) {
    insert_exec_status = val;
    __isset.insert_exec_status = true;
  }

  void __set_error_log(const std::vector<std::string> & val) {
    error_log = val;
    __isset.error_log = true;
  }

  bool operator == (const TReportExecStatusParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.query_id != rhs.__isset.query_id)
      return false;
    else if (__isset.query_id && !(query_id == rhs.query_id))
      return false;
    if (__isset.backend_num != rhs.__isset.backend_num)
      return false;
    else if (__isset.backend_num && !(backend_num == rhs.backend_num))
      return false;
    if (__isset.fragment_instance_id != rhs.__isset.fragment_instance_id)
      return false;
    else if (__isset.fragment_instance_id && !(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (__isset.done != rhs.__isset.done)
      return false;
    else if (__isset.done && !(done == rhs.done))
      return false;
    if (__isset.profile != rhs.__isset.profile)
      return false;
    else if (__isset.profile && !(profile == rhs.profile))
      return false;
    if (__isset.insert_exec_status != rhs.__isset.insert_exec_status)
      return false;
    else if (__isset.insert_exec_status && !(insert_exec_status == rhs.insert_exec_status))
      return false;
    if (__isset.error_log != rhs.__isset.error_log)
      return false;
    else if (__isset.error_log && !(error_log == rhs.error_log))
      return false;
    return true;
  }
  bool operator != (const TReportExecStatusParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReportExecStatusParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TReportExecStatusParams &a, TReportExecStatusParams &b);

typedef struct _TReportExecStatusResult__isset {
  _TReportExecStatusResult__isset() : status(false) {}
  bool status;
} _TReportExecStatusResult__isset;

class TReportExecStatusResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TReportExecStatusResult() {
  }

  virtual ~TReportExecStatusResult() throw() {}

   ::impala::TStatus status;

  _TReportExecStatusResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TReportExecStatusResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TReportExecStatusResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TReportExecStatusResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TReportExecStatusResult &a, TReportExecStatusResult &b);

typedef struct _TCancelPlanFragmentParams__isset {
  _TCancelPlanFragmentParams__isset() : fragment_instance_id(false) {}
  bool fragment_instance_id;
} _TCancelPlanFragmentParams__isset;

class TCancelPlanFragmentParams {
 public:

  static const char* ascii_fingerprint; // = "7A58C455A7D49FCE68DC528A7710E205";
  static const uint8_t binary_fingerprint[16]; // = {0x7A,0x58,0xC4,0x55,0xA7,0xD4,0x9F,0xCE,0x68,0xDC,0x52,0x8A,0x77,0x10,0xE2,0x05};

  TCancelPlanFragmentParams() : protocol_version((ImpalaInternalServiceVersion::type)0) {
  }

  virtual ~TCancelPlanFragmentParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TUniqueId fragment_instance_id;

  _TCancelPlanFragmentParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_fragment_instance_id(const  ::impala::TUniqueId& val) {
    fragment_instance_id = val;
    __isset.fragment_instance_id = true;
  }

  bool operator == (const TCancelPlanFragmentParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.fragment_instance_id != rhs.__isset.fragment_instance_id)
      return false;
    else if (__isset.fragment_instance_id && !(fragment_instance_id == rhs.fragment_instance_id))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelPlanFragmentParams &a, TCancelPlanFragmentParams &b);

typedef struct _TCancelPlanFragmentResult__isset {
  _TCancelPlanFragmentResult__isset() : status(false) {}
  bool status;
} _TCancelPlanFragmentResult__isset;

class TCancelPlanFragmentResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TCancelPlanFragmentResult() {
  }

  virtual ~TCancelPlanFragmentResult() throw() {}

   ::impala::TStatus status;

  _TCancelPlanFragmentResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TCancelPlanFragmentResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCancelPlanFragmentResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCancelPlanFragmentResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCancelPlanFragmentResult &a, TCancelPlanFragmentResult &b);

typedef struct _TTransmitDataParams__isset {
  _TTransmitDataParams__isset() : dest_fragment_instance_id(false), sender_id(false), dest_node_id(false), row_batch(false), eos(false) {}
  bool dest_fragment_instance_id;
  bool sender_id;
  bool dest_node_id;
  bool row_batch;
  bool eos;
} _TTransmitDataParams__isset;

class TTransmitDataParams {
 public:

  static const char* ascii_fingerprint; // = "1AC10B2F2FEF68422582BE2F35DD1630";
  static const uint8_t binary_fingerprint[16]; // = {0x1A,0xC1,0x0B,0x2F,0x2F,0xEF,0x68,0x42,0x25,0x82,0xBE,0x2F,0x35,0xDD,0x16,0x30};

  TTransmitDataParams() : protocol_version((ImpalaInternalServiceVersion::type)0), sender_id(0), dest_node_id(0), eos(0) {
  }

  virtual ~TTransmitDataParams() throw() {}

  ImpalaInternalServiceVersion::type protocol_version;
   ::impala::TUniqueId dest_fragment_instance_id;
  int32_t sender_id;
   ::impala::TPlanNodeId dest_node_id;
   ::impala::TRowBatch row_batch;
  bool eos;

  _TTransmitDataParams__isset __isset;

  void __set_protocol_version(const ImpalaInternalServiceVersion::type val) {
    protocol_version = val;
  }

  void __set_dest_fragment_instance_id(const  ::impala::TUniqueId& val) {
    dest_fragment_instance_id = val;
    __isset.dest_fragment_instance_id = true;
  }

  void __set_sender_id(const int32_t val) {
    sender_id = val;
    __isset.sender_id = true;
  }

  void __set_dest_node_id(const  ::impala::TPlanNodeId val) {
    dest_node_id = val;
    __isset.dest_node_id = true;
  }

  void __set_row_batch(const  ::impala::TRowBatch& val) {
    row_batch = val;
    __isset.row_batch = true;
  }

  void __set_eos(const bool val) {
    eos = val;
    __isset.eos = true;
  }

  bool operator == (const TTransmitDataParams & rhs) const
  {
    if (!(protocol_version == rhs.protocol_version))
      return false;
    if (__isset.dest_fragment_instance_id != rhs.__isset.dest_fragment_instance_id)
      return false;
    else if (__isset.dest_fragment_instance_id && !(dest_fragment_instance_id == rhs.dest_fragment_instance_id))
      return false;
    if (__isset.sender_id != rhs.__isset.sender_id)
      return false;
    else if (__isset.sender_id && !(sender_id == rhs.sender_id))
      return false;
    if (__isset.dest_node_id != rhs.__isset.dest_node_id)
      return false;
    else if (__isset.dest_node_id && !(dest_node_id == rhs.dest_node_id))
      return false;
    if (__isset.row_batch != rhs.__isset.row_batch)
      return false;
    else if (__isset.row_batch && !(row_batch == rhs.row_batch))
      return false;
    if (__isset.eos != rhs.__isset.eos)
      return false;
    else if (__isset.eos && !(eos == rhs.eos))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTransmitDataParams &a, TTransmitDataParams &b);

typedef struct _TTransmitDataResult__isset {
  _TTransmitDataResult__isset() : status(false) {}
  bool status;
} _TTransmitDataResult__isset;

class TTransmitDataResult {
 public:

  static const char* ascii_fingerprint; // = "BA609E39B08A478BB74F0F877E3C5C4A";
  static const uint8_t binary_fingerprint[16]; // = {0xBA,0x60,0x9E,0x39,0xB0,0x8A,0x47,0x8B,0xB7,0x4F,0x0F,0x87,0x7E,0x3C,0x5C,0x4A};

  TTransmitDataResult() {
  }

  virtual ~TTransmitDataResult() throw() {}

   ::impala::TStatus status;

  _TTransmitDataResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TTransmitDataResult & rhs) const
  {
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TTransmitDataResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTransmitDataResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTransmitDataResult &a, TTransmitDataResult &b);


class TResolveRequestPoolParams {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  TResolveRequestPoolParams() : user(), requested_pool() {
  }

  virtual ~TResolveRequestPoolParams() throw() {}

  std::string user;
  std::string requested_pool;

  void __set_user(const std::string& val) {
    user = val;
  }

  void __set_requested_pool(const std::string& val) {
    requested_pool = val;
  }

  bool operator == (const TResolveRequestPoolParams & rhs) const
  {
    if (!(user == rhs.user))
      return false;
    if (!(requested_pool == rhs.requested_pool))
      return false;
    return true;
  }
  bool operator != (const TResolveRequestPoolParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResolveRequestPoolParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TResolveRequestPoolParams &a, TResolveRequestPoolParams &b);

typedef struct _TResolveRequestPoolResult__isset {
  _TResolveRequestPoolResult__isset() : resolved_pool(false), has_access(false), status(false) {}
  bool resolved_pool;
  bool has_access;
  bool status;
} _TResolveRequestPoolResult__isset;

class TResolveRequestPoolResult {
 public:

  static const char* ascii_fingerprint; // = "CB2EDE0377B4C345EB475996115267CC";
  static const uint8_t binary_fingerprint[16]; // = {0xCB,0x2E,0xDE,0x03,0x77,0xB4,0xC3,0x45,0xEB,0x47,0x59,0x96,0x11,0x52,0x67,0xCC};

  TResolveRequestPoolResult() : resolved_pool(), has_access(0) {
  }

  virtual ~TResolveRequestPoolResult() throw() {}

  std::string resolved_pool;
  bool has_access;
   ::impala::TStatus status;

  _TResolveRequestPoolResult__isset __isset;

  void __set_resolved_pool(const std::string& val) {
    resolved_pool = val;
    __isset.resolved_pool = true;
  }

  void __set_has_access(const bool val) {
    has_access = val;
    __isset.has_access = true;
  }

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
    __isset.status = true;
  }

  bool operator == (const TResolveRequestPoolResult & rhs) const
  {
    if (__isset.resolved_pool != rhs.__isset.resolved_pool)
      return false;
    else if (__isset.resolved_pool && !(resolved_pool == rhs.resolved_pool))
      return false;
    if (__isset.has_access != rhs.__isset.has_access)
      return false;
    else if (__isset.has_access && !(has_access == rhs.has_access))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TResolveRequestPoolResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TResolveRequestPoolResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TResolveRequestPoolResult &a, TResolveRequestPoolResult &b);


class TPoolConfigParams {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TPoolConfigParams() : pool() {
  }

  virtual ~TPoolConfigParams() throw() {}

  std::string pool;

  void __set_pool(const std::string& val) {
    pool = val;
  }

  bool operator == (const TPoolConfigParams & rhs) const
  {
    if (!(pool == rhs.pool))
      return false;
    return true;
  }
  bool operator != (const TPoolConfigParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPoolConfigParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPoolConfigParams &a, TPoolConfigParams &b);


class TPoolConfigResult {
 public:

  static const char* ascii_fingerprint; // = "EA2D65F1E0BB78760205682082304B41";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x2D,0x65,0xF1,0xE0,0xBB,0x78,0x76,0x02,0x05,0x68,0x20,0x82,0x30,0x4B,0x41};

  TPoolConfigResult() : max_requests(0), max_queued(0), mem_limit(0) {
  }

  virtual ~TPoolConfigResult() throw() {}

  int64_t max_requests;
  int64_t max_queued;
  int64_t mem_limit;

  void __set_max_requests(const int64_t val) {
    max_requests = val;
  }

  void __set_max_queued(const int64_t val) {
    max_queued = val;
  }

  void __set_mem_limit(const int64_t val) {
    mem_limit = val;
  }

  bool operator == (const TPoolConfigResult & rhs) const
  {
    if (!(max_requests == rhs.max_requests))
      return false;
    if (!(max_queued == rhs.max_queued))
      return false;
    if (!(mem_limit == rhs.mem_limit))
      return false;
    return true;
  }
  bool operator != (const TPoolConfigResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPoolConfigResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPoolConfigResult &a, TPoolConfigResult &b);

} // namespace

#endif
