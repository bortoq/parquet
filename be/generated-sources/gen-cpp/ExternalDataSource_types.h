/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ExternalDataSource_TYPES_H
#define ExternalDataSource_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Status_types.h"
#include "Data_types.h"
#include "Types_types.h"


namespace impala { namespace extdatasource {

struct TComparisonOp {
  enum type {
    LT = 0,
    LE = 1,
    EQ = 2,
    NE = 3,
    GE = 4,
    GT = 5
  };
};

extern const std::map<int, const char*> _TComparisonOp_VALUES_TO_NAMES;

typedef struct _TColumnDesc__isset {
  _TColumnDesc__isset() : name(false), type(false) {}
  bool name;
  bool type;
} _TColumnDesc__isset;

class TColumnDesc {
 public:

  static const char* ascii_fingerprint; // = "BFA02864C23EDEA0AE4921298E19038D";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0xA0,0x28,0x64,0xC2,0x3E,0xDE,0xA0,0xAE,0x49,0x21,0x29,0x8E,0x19,0x03,0x8D};

  TColumnDesc() : name() {
  }

  virtual ~TColumnDesc() throw() {}

  std::string name;
   ::impala::TColumnType type;

  _TColumnDesc__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
    __isset.name = true;
  }

  void __set_type(const  ::impala::TColumnType& val) {
    type = val;
    __isset.type = true;
  }

  bool operator == (const TColumnDesc & rhs) const
  {
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const TColumnDesc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TColumnDesc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TColumnDesc &a, TColumnDesc &b);

typedef struct _TTableSchema__isset {
  _TTableSchema__isset() : cols(false) {}
  bool cols;
} _TTableSchema__isset;

class TTableSchema {
 public:

  static const char* ascii_fingerprint; // = "A5A07B01712444F7593361153543C3B5";
  static const uint8_t binary_fingerprint[16]; // = {0xA5,0xA0,0x7B,0x01,0x71,0x24,0x44,0xF7,0x59,0x33,0x61,0x15,0x35,0x43,0xC3,0xB5};

  TTableSchema() {
  }

  virtual ~TTableSchema() throw() {}

  std::vector<TColumnDesc>  cols;

  _TTableSchema__isset __isset;

  void __set_cols(const std::vector<TColumnDesc> & val) {
    cols = val;
    __isset.cols = true;
  }

  bool operator == (const TTableSchema & rhs) const
  {
    if (__isset.cols != rhs.__isset.cols)
      return false;
    else if (__isset.cols && !(cols == rhs.cols))
      return false;
    return true;
  }
  bool operator != (const TTableSchema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableSchema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableSchema &a, TTableSchema &b);

typedef struct _TRowBatch__isset {
  _TRowBatch__isset() : cols(false), num_rows(false) {}
  bool cols;
  bool num_rows;
} _TRowBatch__isset;

class TRowBatch {
 public:

  static const char* ascii_fingerprint; // = "33410192E9BE03B57CBFB23890CF8386";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x41,0x01,0x92,0xE9,0xBE,0x03,0xB5,0x7C,0xBF,0xB2,0x38,0x90,0xCF,0x83,0x86};

  TRowBatch() : num_rows(0) {
  }

  virtual ~TRowBatch() throw() {}

  std::vector< ::impala::TColumnData>  cols;
  int64_t num_rows;

  _TRowBatch__isset __isset;

  void __set_cols(const std::vector< ::impala::TColumnData> & val) {
    cols = val;
    __isset.cols = true;
  }

  void __set_num_rows(const int64_t val) {
    num_rows = val;
    __isset.num_rows = true;
  }

  bool operator == (const TRowBatch & rhs) const
  {
    if (__isset.cols != rhs.__isset.cols)
      return false;
    else if (__isset.cols && !(cols == rhs.cols))
      return false;
    if (__isset.num_rows != rhs.__isset.num_rows)
      return false;
    else if (__isset.num_rows && !(num_rows == rhs.num_rows))
      return false;
    return true;
  }
  bool operator != (const TRowBatch &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TRowBatch & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TRowBatch &a, TRowBatch &b);

typedef struct _TBinaryPredicate__isset {
  _TBinaryPredicate__isset() : col(false), op(false), value(false) {}
  bool col;
  bool op;
  bool value;
} _TBinaryPredicate__isset;

class TBinaryPredicate {
 public:

  static const char* ascii_fingerprint; // = "DCCD75726CBAD1904AF4392E7A6735F6";
  static const uint8_t binary_fingerprint[16]; // = {0xDC,0xCD,0x75,0x72,0x6C,0xBA,0xD1,0x90,0x4A,0xF4,0x39,0x2E,0x7A,0x67,0x35,0xF6};

  TBinaryPredicate() : op((TComparisonOp::type)0) {
  }

  virtual ~TBinaryPredicate() throw() {}

  TColumnDesc col;
  TComparisonOp::type op;
   ::impala::TColumnValue value;

  _TBinaryPredicate__isset __isset;

  void __set_col(const TColumnDesc& val) {
    col = val;
    __isset.col = true;
  }

  void __set_op(const TComparisonOp::type val) {
    op = val;
    __isset.op = true;
  }

  void __set_value(const  ::impala::TColumnValue& val) {
    value = val;
    __isset.value = true;
  }

  bool operator == (const TBinaryPredicate & rhs) const
  {
    if (__isset.col != rhs.__isset.col)
      return false;
    else if (__isset.col && !(col == rhs.col))
      return false;
    if (__isset.op != rhs.__isset.op)
      return false;
    else if (__isset.op && !(op == rhs.op))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const TBinaryPredicate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TBinaryPredicate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TBinaryPredicate &a, TBinaryPredicate &b);

typedef struct _TPrepareParams__isset {
  _TPrepareParams__isset() : table_name(false), init_string(false), predicates(false) {}
  bool table_name;
  bool init_string;
  bool predicates;
} _TPrepareParams__isset;

class TPrepareParams {
 public:

  static const char* ascii_fingerprint; // = "6E44797D3683CAFB95BB0B1A5DFA66A6";
  static const uint8_t binary_fingerprint[16]; // = {0x6E,0x44,0x79,0x7D,0x36,0x83,0xCA,0xFB,0x95,0xBB,0x0B,0x1A,0x5D,0xFA,0x66,0xA6};

  TPrepareParams() : table_name(), init_string() {
  }

  virtual ~TPrepareParams() throw() {}

  std::string table_name;
  std::string init_string;
  std::vector<std::vector<TBinaryPredicate> >  predicates;

  _TPrepareParams__isset __isset;

  void __set_table_name(const std::string& val) {
    table_name = val;
    __isset.table_name = true;
  }

  void __set_init_string(const std::string& val) {
    init_string = val;
    __isset.init_string = true;
  }

  void __set_predicates(const std::vector<std::vector<TBinaryPredicate> > & val) {
    predicates = val;
    __isset.predicates = true;
  }

  bool operator == (const TPrepareParams & rhs) const
  {
    if (__isset.table_name != rhs.__isset.table_name)
      return false;
    else if (__isset.table_name && !(table_name == rhs.table_name))
      return false;
    if (__isset.init_string != rhs.__isset.init_string)
      return false;
    else if (__isset.init_string && !(init_string == rhs.init_string))
      return false;
    if (__isset.predicates != rhs.__isset.predicates)
      return false;
    else if (__isset.predicates && !(predicates == rhs.predicates))
      return false;
    return true;
  }
  bool operator != (const TPrepareParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrepareParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPrepareParams &a, TPrepareParams &b);

typedef struct _TPrepareResult__isset {
  _TPrepareResult__isset() : num_rows_estimate(false), accepted_conjuncts(false) {}
  bool num_rows_estimate;
  bool accepted_conjuncts;
} _TPrepareResult__isset;

class TPrepareResult {
 public:

  static const char* ascii_fingerprint; // = "73BD13246666089DA2F0FD0FE55D6992";
  static const uint8_t binary_fingerprint[16]; // = {0x73,0xBD,0x13,0x24,0x66,0x66,0x08,0x9D,0xA2,0xF0,0xFD,0x0F,0xE5,0x5D,0x69,0x92};

  TPrepareResult() : num_rows_estimate(0) {
  }

  virtual ~TPrepareResult() throw() {}

   ::impala::TStatus status;
  int64_t num_rows_estimate;
  std::vector<int32_t>  accepted_conjuncts;

  _TPrepareResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
  }

  void __set_num_rows_estimate(const int64_t val) {
    num_rows_estimate = val;
    __isset.num_rows_estimate = true;
  }

  void __set_accepted_conjuncts(const std::vector<int32_t> & val) {
    accepted_conjuncts = val;
    __isset.accepted_conjuncts = true;
  }

  bool operator == (const TPrepareResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.num_rows_estimate != rhs.__isset.num_rows_estimate)
      return false;
    else if (__isset.num_rows_estimate && !(num_rows_estimate == rhs.num_rows_estimate))
      return false;
    if (__isset.accepted_conjuncts != rhs.__isset.accepted_conjuncts)
      return false;
    else if (__isset.accepted_conjuncts && !(accepted_conjuncts == rhs.accepted_conjuncts))
      return false;
    return true;
  }
  bool operator != (const TPrepareResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPrepareResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPrepareResult &a, TPrepareResult &b);

typedef struct _TOpenParams__isset {
  _TOpenParams__isset() : query_id(false), table_name(false), init_string(false), authenticated_user_name(false), row_schema(false), batch_size(false), predicates(false), limit(false) {}
  bool query_id;
  bool table_name;
  bool init_string;
  bool authenticated_user_name;
  bool row_schema;
  bool batch_size;
  bool predicates;
  bool limit;
} _TOpenParams__isset;

class TOpenParams {
 public:

  static const char* ascii_fingerprint; // = "5489AA8C0160D326DE2D1493A68C9042";
  static const uint8_t binary_fingerprint[16]; // = {0x54,0x89,0xAA,0x8C,0x01,0x60,0xD3,0x26,0xDE,0x2D,0x14,0x93,0xA6,0x8C,0x90,0x42};

  TOpenParams() : table_name(), init_string(), authenticated_user_name(), batch_size(0), limit(0) {
  }

  virtual ~TOpenParams() throw() {}

   ::impala::TUniqueId query_id;
  std::string table_name;
  std::string init_string;
  std::string authenticated_user_name;
  TTableSchema row_schema;
  int32_t batch_size;
  std::vector<std::vector<TBinaryPredicate> >  predicates;
  int64_t limit;

  _TOpenParams__isset __isset;

  void __set_query_id(const  ::impala::TUniqueId& val) {
    query_id = val;
    __isset.query_id = true;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
    __isset.table_name = true;
  }

  void __set_init_string(const std::string& val) {
    init_string = val;
    __isset.init_string = true;
  }

  void __set_authenticated_user_name(const std::string& val) {
    authenticated_user_name = val;
    __isset.authenticated_user_name = true;
  }

  void __set_row_schema(const TTableSchema& val) {
    row_schema = val;
    __isset.row_schema = true;
  }

  void __set_batch_size(const int32_t val) {
    batch_size = val;
    __isset.batch_size = true;
  }

  void __set_predicates(const std::vector<std::vector<TBinaryPredicate> > & val) {
    predicates = val;
    __isset.predicates = true;
  }

  void __set_limit(const int64_t val) {
    limit = val;
    __isset.limit = true;
  }

  bool operator == (const TOpenParams & rhs) const
  {
    if (__isset.query_id != rhs.__isset.query_id)
      return false;
    else if (__isset.query_id && !(query_id == rhs.query_id))
      return false;
    if (__isset.table_name != rhs.__isset.table_name)
      return false;
    else if (__isset.table_name && !(table_name == rhs.table_name))
      return false;
    if (__isset.init_string != rhs.__isset.init_string)
      return false;
    else if (__isset.init_string && !(init_string == rhs.init_string))
      return false;
    if (__isset.authenticated_user_name != rhs.__isset.authenticated_user_name)
      return false;
    else if (__isset.authenticated_user_name && !(authenticated_user_name == rhs.authenticated_user_name))
      return false;
    if (__isset.row_schema != rhs.__isset.row_schema)
      return false;
    else if (__isset.row_schema && !(row_schema == rhs.row_schema))
      return false;
    if (__isset.batch_size != rhs.__isset.batch_size)
      return false;
    else if (__isset.batch_size && !(batch_size == rhs.batch_size))
      return false;
    if (__isset.predicates != rhs.__isset.predicates)
      return false;
    else if (__isset.predicates && !(predicates == rhs.predicates))
      return false;
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    return true;
  }
  bool operator != (const TOpenParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOpenParams &a, TOpenParams &b);

typedef struct _TOpenResult__isset {
  _TOpenResult__isset() : scan_handle(false) {}
  bool scan_handle;
} _TOpenResult__isset;

class TOpenResult {
 public:

  static const char* ascii_fingerprint; // = "3D3D48AAE44702453D9901338EB31766";
  static const uint8_t binary_fingerprint[16]; // = {0x3D,0x3D,0x48,0xAA,0xE4,0x47,0x02,0x45,0x3D,0x99,0x01,0x33,0x8E,0xB3,0x17,0x66};

  TOpenResult() : scan_handle() {
  }

  virtual ~TOpenResult() throw() {}

   ::impala::TStatus status;
  std::string scan_handle;

  _TOpenResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
  }

  void __set_scan_handle(const std::string& val) {
    scan_handle = val;
    __isset.scan_handle = true;
  }

  bool operator == (const TOpenResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.scan_handle != rhs.__isset.scan_handle)
      return false;
    else if (__isset.scan_handle && !(scan_handle == rhs.scan_handle))
      return false;
    return true;
  }
  bool operator != (const TOpenResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TOpenResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TOpenResult &a, TOpenResult &b);

typedef struct _TGetNextParams__isset {
  _TGetNextParams__isset() : scan_handle(false) {}
  bool scan_handle;
} _TGetNextParams__isset;

class TGetNextParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TGetNextParams() : scan_handle() {
  }

  virtual ~TGetNextParams() throw() {}

  std::string scan_handle;

  _TGetNextParams__isset __isset;

  void __set_scan_handle(const std::string& val) {
    scan_handle = val;
    __isset.scan_handle = true;
  }

  bool operator == (const TGetNextParams & rhs) const
  {
    if (__isset.scan_handle != rhs.__isset.scan_handle)
      return false;
    else if (__isset.scan_handle && !(scan_handle == rhs.scan_handle))
      return false;
    return true;
  }
  bool operator != (const TGetNextParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetNextParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetNextParams &a, TGetNextParams &b);

typedef struct _TGetNextResult__isset {
  _TGetNextResult__isset() : eos(false), rows(false) {}
  bool eos;
  bool rows;
} _TGetNextResult__isset;

class TGetNextResult {
 public:

  static const char* ascii_fingerprint; // = "83B8F197AFF989F2F09E2E99A34959F8";
  static const uint8_t binary_fingerprint[16]; // = {0x83,0xB8,0xF1,0x97,0xAF,0xF9,0x89,0xF2,0xF0,0x9E,0x2E,0x99,0xA3,0x49,0x59,0xF8};

  TGetNextResult() : eos(0) {
  }

  virtual ~TGetNextResult() throw() {}

   ::impala::TStatus status;
  bool eos;
  TRowBatch rows;

  _TGetNextResult__isset __isset;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
  }

  void __set_eos(const bool val) {
    eos = val;
    __isset.eos = true;
  }

  void __set_rows(const TRowBatch& val) {
    rows = val;
    __isset.rows = true;
  }

  bool operator == (const TGetNextResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (__isset.eos != rhs.__isset.eos)
      return false;
    else if (__isset.eos && !(eos == rhs.eos))
      return false;
    if (__isset.rows != rhs.__isset.rows)
      return false;
    else if (__isset.rows && !(rows == rhs.rows))
      return false;
    return true;
  }
  bool operator != (const TGetNextResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TGetNextResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TGetNextResult &a, TGetNextResult &b);

typedef struct _TCloseParams__isset {
  _TCloseParams__isset() : scan_handle(false) {}
  bool scan_handle;
} _TCloseParams__isset;

class TCloseParams {
 public:

  static const char* ascii_fingerprint; // = "66E694018C17E5B65A59AE8F55CCA3CD";
  static const uint8_t binary_fingerprint[16]; // = {0x66,0xE6,0x94,0x01,0x8C,0x17,0xE5,0xB6,0x5A,0x59,0xAE,0x8F,0x55,0xCC,0xA3,0xCD};

  TCloseParams() : scan_handle() {
  }

  virtual ~TCloseParams() throw() {}

  std::string scan_handle;

  _TCloseParams__isset __isset;

  void __set_scan_handle(const std::string& val) {
    scan_handle = val;
    __isset.scan_handle = true;
  }

  bool operator == (const TCloseParams & rhs) const
  {
    if (__isset.scan_handle != rhs.__isset.scan_handle)
      return false;
    else if (__isset.scan_handle && !(scan_handle == rhs.scan_handle))
      return false;
    return true;
  }
  bool operator != (const TCloseParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseParams &a, TCloseParams &b);


class TCloseResult {
 public:

  static const char* ascii_fingerprint; // = "5D172D269EB9D48C37F2702186BA51B0";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0x17,0x2D,0x26,0x9E,0xB9,0xD4,0x8C,0x37,0xF2,0x70,0x21,0x86,0xBA,0x51,0xB0};

  TCloseResult() {
  }

  virtual ~TCloseResult() throw() {}

   ::impala::TStatus status;

  void __set_status(const  ::impala::TStatus& val) {
    status = val;
  }

  bool operator == (const TCloseResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const TCloseResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCloseResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCloseResult &a, TCloseResult &b);

}} // namespace

#endif
