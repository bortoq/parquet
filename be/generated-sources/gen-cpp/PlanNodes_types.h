/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef PlanNodes_TYPES_H
#define PlanNodes_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "CatalogObjects_types.h"
#include "ExecStats_types.h"
#include "Exprs_types.h"
#include "Types_types.h"
#include "ExternalDataSource_types.h"


namespace impala {

struct TPlanNodeType {
  enum type {
    HDFS_SCAN_NODE = 0,
    HBASE_SCAN_NODE = 1,
    HASH_JOIN_NODE = 2,
    AGGREGATION_NODE = 3,
    SORT_NODE = 4,
    EXCHANGE_NODE = 5,
    UNION_NODE = 6,
    SELECT_NODE = 7,
    CROSS_JOIN_NODE = 8,
    DATA_SOURCE_NODE = 9
  };
};

extern const std::map<int, const char*> _TPlanNodeType_VALUES_TO_NAMES;

struct TExecNodePhase {
  enum type {
    PREPARE = 0,
    OPEN = 1,
    GETNEXT = 2,
    CLOSE = 3,
    INVALID = 4
  };
};

extern const std::map<int, const char*> _TExecNodePhase_VALUES_TO_NAMES;

struct TDebugAction {
  enum type {
    WAIT = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _TDebugAction_VALUES_TO_NAMES;

struct TJoinOp {
  enum type {
    INNER_JOIN = 0,
    LEFT_OUTER_JOIN = 1,
    LEFT_SEMI_JOIN = 2,
    RIGHT_OUTER_JOIN = 3,
    FULL_OUTER_JOIN = 4,
    CROSS_JOIN = 5
  };
};

extern const std::map<int, const char*> _TJoinOp_VALUES_TO_NAMES;


class THdfsFileSplit {
 public:

  static const char* ascii_fingerprint; // = "9118FDD77343DD231D97C424A53D2DCF";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0x18,0xFD,0xD7,0x73,0x43,0xDD,0x23,0x1D,0x97,0xC4,0x24,0xA5,0x3D,0x2D,0xCF};

  THdfsFileSplit() : path(), offset(0), length(0), partition_id(0), file_length(0) {
  }

  virtual ~THdfsFileSplit() throw() {}

  std::string path;
  int64_t offset;
  int64_t length;
  int64_t partition_id;
  int64_t file_length;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_offset(const int64_t val) {
    offset = val;
  }

  void __set_length(const int64_t val) {
    length = val;
  }

  void __set_partition_id(const int64_t val) {
    partition_id = val;
  }

  void __set_file_length(const int64_t val) {
    file_length = val;
  }

  bool operator == (const THdfsFileSplit & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(offset == rhs.offset))
      return false;
    if (!(length == rhs.length))
      return false;
    if (!(partition_id == rhs.partition_id))
      return false;
    if (!(file_length == rhs.file_length))
      return false;
    return true;
  }
  bool operator != (const THdfsFileSplit &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsFileSplit & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsFileSplit &a, THdfsFileSplit &b);

typedef struct _THBaseKeyRange__isset {
  _THBaseKeyRange__isset() : startKey(false), stopKey(false) {}
  bool startKey;
  bool stopKey;
} _THBaseKeyRange__isset;

class THBaseKeyRange {
 public:

  static const char* ascii_fingerprint; // = "D0297FC5011701BD87898CC36146A565";
  static const uint8_t binary_fingerprint[16]; // = {0xD0,0x29,0x7F,0xC5,0x01,0x17,0x01,0xBD,0x87,0x89,0x8C,0xC3,0x61,0x46,0xA5,0x65};

  THBaseKeyRange() : startKey(), stopKey() {
  }

  virtual ~THBaseKeyRange() throw() {}

  std::string startKey;
  std::string stopKey;

  _THBaseKeyRange__isset __isset;

  void __set_startKey(const std::string& val) {
    startKey = val;
    __isset.startKey = true;
  }

  void __set_stopKey(const std::string& val) {
    stopKey = val;
    __isset.stopKey = true;
  }

  bool operator == (const THBaseKeyRange & rhs) const
  {
    if (__isset.startKey != rhs.__isset.startKey)
      return false;
    else if (__isset.startKey && !(startKey == rhs.startKey))
      return false;
    if (__isset.stopKey != rhs.__isset.stopKey)
      return false;
    else if (__isset.stopKey && !(stopKey == rhs.stopKey))
      return false;
    return true;
  }
  bool operator != (const THBaseKeyRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseKeyRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseKeyRange &a, THBaseKeyRange &b);

typedef struct _TScanRange__isset {
  _TScanRange__isset() : hdfs_file_split(false), hbase_key_range(false) {}
  bool hdfs_file_split;
  bool hbase_key_range;
} _TScanRange__isset;

class TScanRange {
 public:

  static const char* ascii_fingerprint; // = "3375FEB6FC792611F5B83B498340EAA2";
  static const uint8_t binary_fingerprint[16]; // = {0x33,0x75,0xFE,0xB6,0xFC,0x79,0x26,0x11,0xF5,0xB8,0x3B,0x49,0x83,0x40,0xEA,0xA2};

  TScanRange() {
  }

  virtual ~TScanRange() throw() {}

  THdfsFileSplit hdfs_file_split;
  THBaseKeyRange hbase_key_range;

  _TScanRange__isset __isset;

  void __set_hdfs_file_split(const THdfsFileSplit& val) {
    hdfs_file_split = val;
    __isset.hdfs_file_split = true;
  }

  void __set_hbase_key_range(const THBaseKeyRange& val) {
    hbase_key_range = val;
    __isset.hbase_key_range = true;
  }

  bool operator == (const TScanRange & rhs) const
  {
    if (__isset.hdfs_file_split != rhs.__isset.hdfs_file_split)
      return false;
    else if (__isset.hdfs_file_split && !(hdfs_file_split == rhs.hdfs_file_split))
      return false;
    if (__isset.hbase_key_range != rhs.__isset.hbase_key_range)
      return false;
    else if (__isset.hbase_key_range && !(hbase_key_range == rhs.hbase_key_range))
      return false;
    return true;
  }
  bool operator != (const TScanRange &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TScanRange & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TScanRange &a, TScanRange &b);


class THdfsScanNode {
 public:

  static const char* ascii_fingerprint; // = "E86CACEB22240450EDCBEFC3A83970E4";
  static const uint8_t binary_fingerprint[16]; // = {0xE8,0x6C,0xAC,0xEB,0x22,0x24,0x04,0x50,0xED,0xCB,0xEF,0xC3,0xA8,0x39,0x70,0xE4};

  THdfsScanNode() : tuple_id(0) {
  }

  virtual ~THdfsScanNode() throw() {}

   ::impala::TTupleId tuple_id;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  bool operator == (const THdfsScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    return true;
  }
  bool operator != (const THdfsScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsScanNode &a, THdfsScanNode &b);


class TDataSourceScanNode {
 public:

  static const char* ascii_fingerprint; // = "0D14CD341A05C96F074F78074D02ABC6";
  static const uint8_t binary_fingerprint[16]; // = {0x0D,0x14,0xCD,0x34,0x1A,0x05,0xC9,0x6F,0x07,0x4F,0x78,0x07,0x4D,0x02,0xAB,0xC6};

  TDataSourceScanNode() : tuple_id(0), init_string() {
  }

  virtual ~TDataSourceScanNode() throw() {}

   ::impala::TTupleId tuple_id;
   ::impala::TDataSource data_source;
  std::string init_string;
  std::vector<std::vector< ::impala::extdatasource::TBinaryPredicate> >  accepted_predicates;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  void __set_data_source(const  ::impala::TDataSource& val) {
    data_source = val;
  }

  void __set_init_string(const std::string& val) {
    init_string = val;
  }

  void __set_accepted_predicates(const std::vector<std::vector< ::impala::extdatasource::TBinaryPredicate> > & val) {
    accepted_predicates = val;
  }

  bool operator == (const TDataSourceScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(data_source == rhs.data_source))
      return false;
    if (!(init_string == rhs.init_string))
      return false;
    if (!(accepted_predicates == rhs.accepted_predicates))
      return false;
    return true;
  }
  bool operator != (const TDataSourceScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDataSourceScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDataSourceScanNode &a, TDataSourceScanNode &b);


class THBaseFilter {
 public:

  static const char* ascii_fingerprint; // = "AC16F1200213405F9A9267FCBF95F39A";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0x16,0xF1,0x20,0x02,0x13,0x40,0x5F,0x9A,0x92,0x67,0xFC,0xBF,0x95,0xF3,0x9A};

  THBaseFilter() : family(), qualifier(), op_ordinal(0), filter_constant() {
  }

  virtual ~THBaseFilter() throw() {}

  std::string family;
  std::string qualifier;
  int32_t op_ordinal;
  std::string filter_constant;

  void __set_family(const std::string& val) {
    family = val;
  }

  void __set_qualifier(const std::string& val) {
    qualifier = val;
  }

  void __set_op_ordinal(const int32_t val) {
    op_ordinal = val;
  }

  void __set_filter_constant(const std::string& val) {
    filter_constant = val;
  }

  bool operator == (const THBaseFilter & rhs) const
  {
    if (!(family == rhs.family))
      return false;
    if (!(qualifier == rhs.qualifier))
      return false;
    if (!(op_ordinal == rhs.op_ordinal))
      return false;
    if (!(filter_constant == rhs.filter_constant))
      return false;
    return true;
  }
  bool operator != (const THBaseFilter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseFilter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseFilter &a, THBaseFilter &b);

typedef struct _THBaseScanNode__isset {
  _THBaseScanNode__isset() : filters(false), suggested_max_caching(false) {}
  bool filters;
  bool suggested_max_caching;
} _THBaseScanNode__isset;

class THBaseScanNode {
 public:

  static const char* ascii_fingerprint; // = "4C4FA16D796599A2207A67E14BD4DF18";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x4F,0xA1,0x6D,0x79,0x65,0x99,0xA2,0x20,0x7A,0x67,0xE1,0x4B,0xD4,0xDF,0x18};

  THBaseScanNode() : tuple_id(0), table_name(), suggested_max_caching(0) {
  }

  virtual ~THBaseScanNode() throw() {}

   ::impala::TTupleId tuple_id;
  std::string table_name;
  std::vector<THBaseFilter>  filters;
  int32_t suggested_max_caching;

  _THBaseScanNode__isset __isset;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  void __set_table_name(const std::string& val) {
    table_name = val;
  }

  void __set_filters(const std::vector<THBaseFilter> & val) {
    filters = val;
    __isset.filters = true;
  }

  void __set_suggested_max_caching(const int32_t val) {
    suggested_max_caching = val;
    __isset.suggested_max_caching = true;
  }

  bool operator == (const THBaseScanNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.filters != rhs.__isset.filters)
      return false;
    else if (__isset.filters && !(filters == rhs.filters))
      return false;
    if (__isset.suggested_max_caching != rhs.__isset.suggested_max_caching)
      return false;
    else if (__isset.suggested_max_caching && !(suggested_max_caching == rhs.suggested_max_caching))
      return false;
    return true;
  }
  bool operator != (const THBaseScanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THBaseScanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THBaseScanNode &a, THBaseScanNode &b);


class TEqJoinCondition {
 public:

  static const char* ascii_fingerprint; // = "6B26313539BB3F0E5C47C9DAA0D33514";
  static const uint8_t binary_fingerprint[16]; // = {0x6B,0x26,0x31,0x35,0x39,0xBB,0x3F,0x0E,0x5C,0x47,0xC9,0xDA,0xA0,0xD3,0x35,0x14};

  TEqJoinCondition() {
  }

  virtual ~TEqJoinCondition() throw() {}

   ::impala::TExpr left;
   ::impala::TExpr right;

  void __set_left(const  ::impala::TExpr& val) {
    left = val;
  }

  void __set_right(const  ::impala::TExpr& val) {
    right = val;
  }

  bool operator == (const TEqJoinCondition & rhs) const
  {
    if (!(left == rhs.left))
      return false;
    if (!(right == rhs.right))
      return false;
    return true;
  }
  bool operator != (const TEqJoinCondition &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TEqJoinCondition & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TEqJoinCondition &a, TEqJoinCondition &b);

typedef struct _THashJoinNode__isset {
  _THashJoinNode__isset() : other_join_conjuncts(false), add_probe_filters(false) {}
  bool other_join_conjuncts;
  bool add_probe_filters;
} _THashJoinNode__isset;

class THashJoinNode {
 public:

  static const char* ascii_fingerprint; // = "0C42A7D9FAF7B168EE3E1387B25B20F8";
  static const uint8_t binary_fingerprint[16]; // = {0x0C,0x42,0xA7,0xD9,0xFA,0xF7,0xB1,0x68,0xEE,0x3E,0x13,0x87,0xB2,0x5B,0x20,0xF8};

  THashJoinNode() : join_op((TJoinOp::type)0), add_probe_filters(0) {
  }

  virtual ~THashJoinNode() throw() {}

  TJoinOp::type join_op;
  std::vector<TEqJoinCondition>  eq_join_conjuncts;
  std::vector< ::impala::TExpr>  other_join_conjuncts;
  bool add_probe_filters;

  _THashJoinNode__isset __isset;

  void __set_join_op(const TJoinOp::type val) {
    join_op = val;
  }

  void __set_eq_join_conjuncts(const std::vector<TEqJoinCondition> & val) {
    eq_join_conjuncts = val;
  }

  void __set_other_join_conjuncts(const std::vector< ::impala::TExpr> & val) {
    other_join_conjuncts = val;
    __isset.other_join_conjuncts = true;
  }

  void __set_add_probe_filters(const bool val) {
    add_probe_filters = val;
    __isset.add_probe_filters = true;
  }

  bool operator == (const THashJoinNode & rhs) const
  {
    if (!(join_op == rhs.join_op))
      return false;
    if (!(eq_join_conjuncts == rhs.eq_join_conjuncts))
      return false;
    if (__isset.other_join_conjuncts != rhs.__isset.other_join_conjuncts)
      return false;
    else if (__isset.other_join_conjuncts && !(other_join_conjuncts == rhs.other_join_conjuncts))
      return false;
    if (__isset.add_probe_filters != rhs.__isset.add_probe_filters)
      return false;
    else if (__isset.add_probe_filters && !(add_probe_filters == rhs.add_probe_filters))
      return false;
    return true;
  }
  bool operator != (const THashJoinNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THashJoinNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THashJoinNode &a, THashJoinNode &b);

typedef struct _TAggregationNode__isset {
  _TAggregationNode__isset() : grouping_exprs(false), is_merge(false) {}
  bool grouping_exprs;
  bool is_merge;
} _TAggregationNode__isset;

class TAggregationNode {
 public:

  static const char* ascii_fingerprint; // = "55D8FE540D38315C7EABE87740F555CD";
  static const uint8_t binary_fingerprint[16]; // = {0x55,0xD8,0xFE,0x54,0x0D,0x38,0x31,0x5C,0x7E,0xAB,0xE8,0x77,0x40,0xF5,0x55,0xCD};

  TAggregationNode() : agg_tuple_id(0), need_finalize(0), is_merge(0) {
  }

  virtual ~TAggregationNode() throw() {}

  std::vector< ::impala::TExpr>  grouping_exprs;
  std::vector< ::impala::TExpr>  aggregate_functions;
   ::impala::TTupleId agg_tuple_id;
  bool need_finalize;
  bool is_merge;

  _TAggregationNode__isset __isset;

  void __set_grouping_exprs(const std::vector< ::impala::TExpr> & val) {
    grouping_exprs = val;
    __isset.grouping_exprs = true;
  }

  void __set_aggregate_functions(const std::vector< ::impala::TExpr> & val) {
    aggregate_functions = val;
  }

  void __set_agg_tuple_id(const  ::impala::TTupleId val) {
    agg_tuple_id = val;
  }

  void __set_need_finalize(const bool val) {
    need_finalize = val;
  }

  void __set_is_merge(const bool val) {
    is_merge = val;
    __isset.is_merge = true;
  }

  bool operator == (const TAggregationNode & rhs) const
  {
    if (__isset.grouping_exprs != rhs.__isset.grouping_exprs)
      return false;
    else if (__isset.grouping_exprs && !(grouping_exprs == rhs.grouping_exprs))
      return false;
    if (!(aggregate_functions == rhs.aggregate_functions))
      return false;
    if (!(agg_tuple_id == rhs.agg_tuple_id))
      return false;
    if (!(need_finalize == rhs.need_finalize))
      return false;
    if (__isset.is_merge != rhs.__isset.is_merge)
      return false;
    else if (__isset.is_merge && !(is_merge == rhs.is_merge))
      return false;
    return true;
  }
  bool operator != (const TAggregationNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAggregationNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAggregationNode &a, TAggregationNode &b);

typedef struct _TSortInfo__isset {
  _TSortInfo__isset() : sort_tuple_slot_exprs(false) {}
  bool sort_tuple_slot_exprs;
} _TSortInfo__isset;

class TSortInfo {
 public:

  static const char* ascii_fingerprint; // = "767FF1AA0C38E9B43817FCAD64648F0A";
  static const uint8_t binary_fingerprint[16]; // = {0x76,0x7F,0xF1,0xAA,0x0C,0x38,0xE9,0xB4,0x38,0x17,0xFC,0xAD,0x64,0x64,0x8F,0x0A};

  TSortInfo() {
  }

  virtual ~TSortInfo() throw() {}

  std::vector< ::impala::TExpr>  ordering_exprs;
  std::vector<bool>  is_asc_order;
  std::vector<bool>  nulls_first;
  std::vector< ::impala::TExpr>  sort_tuple_slot_exprs;

  _TSortInfo__isset __isset;

  void __set_ordering_exprs(const std::vector< ::impala::TExpr> & val) {
    ordering_exprs = val;
  }

  void __set_is_asc_order(const std::vector<bool> & val) {
    is_asc_order = val;
  }

  void __set_nulls_first(const std::vector<bool> & val) {
    nulls_first = val;
  }

  void __set_sort_tuple_slot_exprs(const std::vector< ::impala::TExpr> & val) {
    sort_tuple_slot_exprs = val;
    __isset.sort_tuple_slot_exprs = true;
  }

  bool operator == (const TSortInfo & rhs) const
  {
    if (!(ordering_exprs == rhs.ordering_exprs))
      return false;
    if (!(is_asc_order == rhs.is_asc_order))
      return false;
    if (!(nulls_first == rhs.nulls_first))
      return false;
    if (__isset.sort_tuple_slot_exprs != rhs.__isset.sort_tuple_slot_exprs)
      return false;
    else if (__isset.sort_tuple_slot_exprs && !(sort_tuple_slot_exprs == rhs.sort_tuple_slot_exprs))
      return false;
    return true;
  }
  bool operator != (const TSortInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSortInfo &a, TSortInfo &b);

typedef struct _TSortNode__isset {
  _TSortNode__isset() : offset(false) {}
  bool offset;
} _TSortNode__isset;

class TSortNode {
 public:

  static const char* ascii_fingerprint; // = "E58C56C1688E828C61AC5E5D67241194";
  static const uint8_t binary_fingerprint[16]; // = {0xE5,0x8C,0x56,0xC1,0x68,0x8E,0x82,0x8C,0x61,0xAC,0x5E,0x5D,0x67,0x24,0x11,0x94};

  TSortNode() : use_top_n(0), offset(0) {
  }

  virtual ~TSortNode() throw() {}

  TSortInfo sort_info;
  bool use_top_n;
  int64_t offset;

  _TSortNode__isset __isset;

  void __set_sort_info(const TSortInfo& val) {
    sort_info = val;
  }

  void __set_use_top_n(const bool val) {
    use_top_n = val;
  }

  void __set_offset(const int64_t val) {
    offset = val;
    __isset.offset = true;
  }

  bool operator == (const TSortNode & rhs) const
  {
    if (!(sort_info == rhs.sort_info))
      return false;
    if (!(use_top_n == rhs.use_top_n))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const TSortNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TSortNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TSortNode &a, TSortNode &b);


class TUnionNode {
 public:

  static const char* ascii_fingerprint; // = "5002A6C9A8028F25A8C1251D9DE8F9C2";
  static const uint8_t binary_fingerprint[16]; // = {0x50,0x02,0xA6,0xC9,0xA8,0x02,0x8F,0x25,0xA8,0xC1,0x25,0x1D,0x9D,0xE8,0xF9,0xC2};

  TUnionNode() : tuple_id(0) {
  }

  virtual ~TUnionNode() throw() {}

   ::impala::TTupleId tuple_id;
  std::vector<std::vector< ::impala::TExpr> >  result_expr_lists;
  std::vector<std::vector< ::impala::TExpr> >  const_expr_lists;

  void __set_tuple_id(const  ::impala::TTupleId val) {
    tuple_id = val;
  }

  void __set_result_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val) {
    result_expr_lists = val;
  }

  void __set_const_expr_lists(const std::vector<std::vector< ::impala::TExpr> > & val) {
    const_expr_lists = val;
  }

  bool operator == (const TUnionNode & rhs) const
  {
    if (!(tuple_id == rhs.tuple_id))
      return false;
    if (!(result_expr_lists == rhs.result_expr_lists))
      return false;
    if (!(const_expr_lists == rhs.const_expr_lists))
      return false;
    return true;
  }
  bool operator != (const TUnionNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TUnionNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TUnionNode &a, TUnionNode &b);

typedef struct _TExchangeNode__isset {
  _TExchangeNode__isset() : sort_info(false), offset(false) {}
  bool sort_info;
  bool offset;
} _TExchangeNode__isset;

class TExchangeNode {
 public:

  static const char* ascii_fingerprint; // = "327F02B7D70DC93E48B7A324A64FF905";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x7F,0x02,0xB7,0xD7,0x0D,0xC9,0x3E,0x48,0xB7,0xA3,0x24,0xA6,0x4F,0xF9,0x05};

  TExchangeNode() : offset(0) {
  }

  virtual ~TExchangeNode() throw() {}

  std::vector< ::impala::TTupleId>  input_row_tuples;
  TSortInfo sort_info;
  int64_t offset;

  _TExchangeNode__isset __isset;

  void __set_input_row_tuples(const std::vector< ::impala::TTupleId> & val) {
    input_row_tuples = val;
  }

  void __set_sort_info(const TSortInfo& val) {
    sort_info = val;
    __isset.sort_info = true;
  }

  void __set_offset(const int64_t val) {
    offset = val;
    __isset.offset = true;
  }

  bool operator == (const TExchangeNode & rhs) const
  {
    if (!(input_row_tuples == rhs.input_row_tuples))
      return false;
    if (__isset.sort_info != rhs.__isset.sort_info)
      return false;
    else if (__isset.sort_info && !(sort_info == rhs.sort_info))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    return true;
  }
  bool operator != (const TExchangeNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TExchangeNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TExchangeNode &a, TExchangeNode &b);

typedef struct _TPlanNode__isset {
  _TPlanNode__isset() : conjuncts(false), hdfs_scan_node(false), hbase_scan_node(false), data_source_node(false), hash_join_node(false), agg_node(false), sort_node(false), union_node(false), exchange_node(false), label(false), label_detail(false), estimated_stats(false) {}
  bool conjuncts;
  bool hdfs_scan_node;
  bool hbase_scan_node;
  bool data_source_node;
  bool hash_join_node;
  bool agg_node;
  bool sort_node;
  bool union_node;
  bool exchange_node;
  bool label;
  bool label_detail;
  bool estimated_stats;
} _TPlanNode__isset;

class TPlanNode {
 public:

  static const char* ascii_fingerprint; // = "8482A5E1DFA8ED00F99E68908E0114B1";
  static const uint8_t binary_fingerprint[16]; // = {0x84,0x82,0xA5,0xE1,0xDF,0xA8,0xED,0x00,0xF9,0x9E,0x68,0x90,0x8E,0x01,0x14,0xB1};

  TPlanNode() : node_id(0), node_type((TPlanNodeType::type)0), num_children(0), limit(0), compact_data(0), label(), label_detail() {
  }

  virtual ~TPlanNode() throw() {}

   ::impala::TPlanNodeId node_id;
  TPlanNodeType::type node_type;
  int32_t num_children;
  int64_t limit;
  std::vector< ::impala::TTupleId>  row_tuples;
  std::vector<bool>  nullable_tuples;
  std::vector< ::impala::TExpr>  conjuncts;
  bool compact_data;
  THdfsScanNode hdfs_scan_node;
  THBaseScanNode hbase_scan_node;
  TDataSourceScanNode data_source_node;
  THashJoinNode hash_join_node;
  TAggregationNode agg_node;
  TSortNode sort_node;
  TUnionNode union_node;
  TExchangeNode exchange_node;
  std::string label;
  std::string label_detail;
   ::impala::TExecStats estimated_stats;

  _TPlanNode__isset __isset;

  void __set_node_id(const  ::impala::TPlanNodeId val) {
    node_id = val;
  }

  void __set_node_type(const TPlanNodeType::type val) {
    node_type = val;
  }

  void __set_num_children(const int32_t val) {
    num_children = val;
  }

  void __set_limit(const int64_t val) {
    limit = val;
  }

  void __set_row_tuples(const std::vector< ::impala::TTupleId> & val) {
    row_tuples = val;
  }

  void __set_nullable_tuples(const std::vector<bool> & val) {
    nullable_tuples = val;
  }

  void __set_conjuncts(const std::vector< ::impala::TExpr> & val) {
    conjuncts = val;
    __isset.conjuncts = true;
  }

  void __set_compact_data(const bool val) {
    compact_data = val;
  }

  void __set_hdfs_scan_node(const THdfsScanNode& val) {
    hdfs_scan_node = val;
    __isset.hdfs_scan_node = true;
  }

  void __set_hbase_scan_node(const THBaseScanNode& val) {
    hbase_scan_node = val;
    __isset.hbase_scan_node = true;
  }

  void __set_data_source_node(const TDataSourceScanNode& val) {
    data_source_node = val;
    __isset.data_source_node = true;
  }

  void __set_hash_join_node(const THashJoinNode& val) {
    hash_join_node = val;
    __isset.hash_join_node = true;
  }

  void __set_agg_node(const TAggregationNode& val) {
    agg_node = val;
    __isset.agg_node = true;
  }

  void __set_sort_node(const TSortNode& val) {
    sort_node = val;
    __isset.sort_node = true;
  }

  void __set_union_node(const TUnionNode& val) {
    union_node = val;
    __isset.union_node = true;
  }

  void __set_exchange_node(const TExchangeNode& val) {
    exchange_node = val;
    __isset.exchange_node = true;
  }

  void __set_label(const std::string& val) {
    label = val;
    __isset.label = true;
  }

  void __set_label_detail(const std::string& val) {
    label_detail = val;
    __isset.label_detail = true;
  }

  void __set_estimated_stats(const  ::impala::TExecStats& val) {
    estimated_stats = val;
    __isset.estimated_stats = true;
  }

  bool operator == (const TPlanNode & rhs) const
  {
    if (!(node_id == rhs.node_id))
      return false;
    if (!(node_type == rhs.node_type))
      return false;
    if (!(num_children == rhs.num_children))
      return false;
    if (!(limit == rhs.limit))
      return false;
    if (!(row_tuples == rhs.row_tuples))
      return false;
    if (!(nullable_tuples == rhs.nullable_tuples))
      return false;
    if (__isset.conjuncts != rhs.__isset.conjuncts)
      return false;
    else if (__isset.conjuncts && !(conjuncts == rhs.conjuncts))
      return false;
    if (!(compact_data == rhs.compact_data))
      return false;
    if (__isset.hdfs_scan_node != rhs.__isset.hdfs_scan_node)
      return false;
    else if (__isset.hdfs_scan_node && !(hdfs_scan_node == rhs.hdfs_scan_node))
      return false;
    if (__isset.hbase_scan_node != rhs.__isset.hbase_scan_node)
      return false;
    else if (__isset.hbase_scan_node && !(hbase_scan_node == rhs.hbase_scan_node))
      return false;
    if (__isset.data_source_node != rhs.__isset.data_source_node)
      return false;
    else if (__isset.data_source_node && !(data_source_node == rhs.data_source_node))
      return false;
    if (__isset.hash_join_node != rhs.__isset.hash_join_node)
      return false;
    else if (__isset.hash_join_node && !(hash_join_node == rhs.hash_join_node))
      return false;
    if (__isset.agg_node != rhs.__isset.agg_node)
      return false;
    else if (__isset.agg_node && !(agg_node == rhs.agg_node))
      return false;
    if (__isset.sort_node != rhs.__isset.sort_node)
      return false;
    else if (__isset.sort_node && !(sort_node == rhs.sort_node))
      return false;
    if (__isset.union_node != rhs.__isset.union_node)
      return false;
    else if (__isset.union_node && !(union_node == rhs.union_node))
      return false;
    if (__isset.exchange_node != rhs.__isset.exchange_node)
      return false;
    else if (__isset.exchange_node && !(exchange_node == rhs.exchange_node))
      return false;
    if (__isset.label != rhs.__isset.label)
      return false;
    else if (__isset.label && !(label == rhs.label))
      return false;
    if (__isset.label_detail != rhs.__isset.label_detail)
      return false;
    else if (__isset.label_detail && !(label_detail == rhs.label_detail))
      return false;
    if (__isset.estimated_stats != rhs.__isset.estimated_stats)
      return false;
    else if (__isset.estimated_stats && !(estimated_stats == rhs.estimated_stats))
      return false;
    return true;
  }
  bool operator != (const TPlanNode &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlanNode & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlanNode &a, TPlanNode &b);


class TPlan {
 public:

  static const char* ascii_fingerprint; // = "7F2B0EECF3BC03516566D224F5865E06";
  static const uint8_t binary_fingerprint[16]; // = {0x7F,0x2B,0x0E,0xEC,0xF3,0xBC,0x03,0x51,0x65,0x66,0xD2,0x24,0xF5,0x86,0x5E,0x06};

  TPlan() {
  }

  virtual ~TPlan() throw() {}

  std::vector<TPlanNode>  nodes;

  void __set_nodes(const std::vector<TPlanNode> & val) {
    nodes = val;
  }

  bool operator == (const TPlan & rhs) const
  {
    if (!(nodes == rhs.nodes))
      return false;
    return true;
  }
  bool operator != (const TPlan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TPlan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TPlan &a, TPlan &b);

} // namespace

#endif
