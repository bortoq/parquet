/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef JniCatalog_TYPES_H
#define JniCatalog_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "CatalogObjects_types.h"
#include "Types_types.h"
#include "Status_types.h"
#include "cli_service_types.h"


namespace impala {

struct TDdlType {
  enum type {
    ALTER_TABLE = 0,
    ALTER_VIEW = 1,
    CREATE_DATABASE = 2,
    CREATE_TABLE = 3,
    CREATE_TABLE_AS_SELECT = 4,
    CREATE_TABLE_LIKE = 5,
    CREATE_VIEW = 6,
    CREATE_FUNCTION = 7,
    COMPUTE_STATS = 8,
    DROP_DATABASE = 9,
    DROP_TABLE = 10,
    DROP_VIEW = 11,
    DROP_FUNCTION = 12,
    CREATE_DATA_SOURCE = 13,
    DROP_DATA_SOURCE = 14
  };
};

extern const std::map<int, const char*> _TDdlType_VALUES_TO_NAMES;

struct TAlterTableType {
  enum type {
    ADD_REPLACE_COLUMNS = 0,
    ADD_PARTITION = 1,
    CHANGE_COLUMN = 2,
    DROP_COLUMN = 3,
    DROP_PARTITION = 4,
    RENAME_TABLE = 5,
    RENAME_VIEW = 6,
    SET_FILE_FORMAT = 7,
    SET_LOCATION = 8,
    SET_TBL_PROPERTIES = 9,
    UPDATE_STATS = 10,
    SET_CACHED = 11
  };
};

extern const std::map<int, const char*> _TAlterTableType_VALUES_TO_NAMES;

typedef struct _TCreateDbParams__isset {
  _TCreateDbParams__isset() : comment(false), location(false), if_not_exists(false) {}
  bool comment;
  bool location;
  bool if_not_exists;
} _TCreateDbParams__isset;

class TCreateDbParams {
 public:

  static const char* ascii_fingerprint; // = "CAD4F97378DF2EFF77F23A193511C552";
  static const uint8_t binary_fingerprint[16]; // = {0xCA,0xD4,0xF9,0x73,0x78,0xDF,0x2E,0xFF,0x77,0xF2,0x3A,0x19,0x35,0x11,0xC5,0x52};

  TCreateDbParams() : db(), comment(), location(), if_not_exists(0) {
  }

  virtual ~TCreateDbParams() throw() {}

  std::string db;
  std::string comment;
  std::string location;
  bool if_not_exists;

  _TCreateDbParams__isset __isset;

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
    __isset.if_not_exists = true;
  }

  bool operator == (const TCreateDbParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.if_not_exists != rhs.__isset.if_not_exists)
      return false;
    else if (__isset.if_not_exists && !(if_not_exists == rhs.if_not_exists))
      return false;
    return true;
  }
  bool operator != (const TCreateDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateDbParams &a, TCreateDbParams &b);

typedef struct _TCreateDataSourceParams__isset {
  _TCreateDataSourceParams__isset() : if_not_exists(false) {}
  bool if_not_exists;
} _TCreateDataSourceParams__isset;

class TCreateDataSourceParams {
 public:

  static const char* ascii_fingerprint; // = "AC2390CD32B1CB5E62BEB2BB6AE77D91";
  static const uint8_t binary_fingerprint[16]; // = {0xAC,0x23,0x90,0xCD,0x32,0xB1,0xCB,0x5E,0x62,0xBE,0xB2,0xBB,0x6A,0xE7,0x7D,0x91};

  TCreateDataSourceParams() : if_not_exists(0) {
  }

  virtual ~TCreateDataSourceParams() throw() {}

   ::impala::TDataSource data_source;
  bool if_not_exists;

  _TCreateDataSourceParams__isset __isset;

  void __set_data_source(const  ::impala::TDataSource& val) {
    data_source = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
    __isset.if_not_exists = true;
  }

  bool operator == (const TCreateDataSourceParams & rhs) const
  {
    if (!(data_source == rhs.data_source))
      return false;
    if (__isset.if_not_exists != rhs.__isset.if_not_exists)
      return false;
    else if (__isset.if_not_exists && !(if_not_exists == rhs.if_not_exists))
      return false;
    return true;
  }
  bool operator != (const TCreateDataSourceParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateDataSourceParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateDataSourceParams &a, TCreateDataSourceParams &b);

typedef struct _TDropDataSourceParams__isset {
  _TDropDataSourceParams__isset() : if_exists(false) {}
  bool if_exists;
} _TDropDataSourceParams__isset;

class TDropDataSourceParams {
 public:

  static const char* ascii_fingerprint; // = "7B7060CC54E4E81C572E3863A6D96736";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0x70,0x60,0xCC,0x54,0xE4,0xE8,0x1C,0x57,0x2E,0x38,0x63,0xA6,0xD9,0x67,0x36};

  TDropDataSourceParams() : data_source(), if_exists(0) {
  }

  virtual ~TDropDataSourceParams() throw() {}

  std::string data_source;
  bool if_exists;

  _TDropDataSourceParams__isset __isset;

  void __set_data_source(const std::string& val) {
    data_source = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
    __isset.if_exists = true;
  }

  bool operator == (const TDropDataSourceParams & rhs) const
  {
    if (!(data_source == rhs.data_source))
      return false;
    if (__isset.if_exists != rhs.__isset.if_exists)
      return false;
    else if (__isset.if_exists && !(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TDropDataSourceParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropDataSourceParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropDataSourceParams &a, TDropDataSourceParams &b);

typedef struct _TCreateFunctionParams__isset {
  _TCreateFunctionParams__isset() : if_not_exists(false) {}
  bool if_not_exists;
} _TCreateFunctionParams__isset;

class TCreateFunctionParams {
 public:

  static const char* ascii_fingerprint; // = "0B43CEC73B0DC55C671E7639DD2A535A";
  static const uint8_t binary_fingerprint[16]; // = {0x0B,0x43,0xCE,0xC7,0x3B,0x0D,0xC5,0x5C,0x67,0x1E,0x76,0x39,0xDD,0x2A,0x53,0x5A};

  TCreateFunctionParams() : if_not_exists(0) {
  }

  virtual ~TCreateFunctionParams() throw() {}

   ::impala::TFunction fn;
  bool if_not_exists;

  _TCreateFunctionParams__isset __isset;

  void __set_fn(const  ::impala::TFunction& val) {
    fn = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
    __isset.if_not_exists = true;
  }

  bool operator == (const TCreateFunctionParams & rhs) const
  {
    if (!(fn == rhs.fn))
      return false;
    if (__isset.if_not_exists != rhs.__isset.if_not_exists)
      return false;
    else if (__isset.if_not_exists && !(if_not_exists == rhs.if_not_exists))
      return false;
    return true;
  }
  bool operator != (const TCreateFunctionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateFunctionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateFunctionParams &a, TCreateFunctionParams &b);

typedef struct _TTableRowFormat__isset {
  _TTableRowFormat__isset() : field_terminator(false), line_terminator(false), escaped_by(false) {}
  bool field_terminator;
  bool line_terminator;
  bool escaped_by;
} _TTableRowFormat__isset;

class TTableRowFormat {
 public:

  static const char* ascii_fingerprint; // = "B2C950B9C25B62CA02C2A8C700FEE26F";
  static const uint8_t binary_fingerprint[16]; // = {0xB2,0xC9,0x50,0xB9,0xC2,0x5B,0x62,0xCA,0x02,0xC2,0xA8,0xC7,0x00,0xFE,0xE2,0x6F};

  TTableRowFormat() : field_terminator(), line_terminator(), escaped_by() {
  }

  virtual ~TTableRowFormat() throw() {}

  std::string field_terminator;
  std::string line_terminator;
  std::string escaped_by;

  _TTableRowFormat__isset __isset;

  void __set_field_terminator(const std::string& val) {
    field_terminator = val;
    __isset.field_terminator = true;
  }

  void __set_line_terminator(const std::string& val) {
    line_terminator = val;
    __isset.line_terminator = true;
  }

  void __set_escaped_by(const std::string& val) {
    escaped_by = val;
    __isset.escaped_by = true;
  }

  bool operator == (const TTableRowFormat & rhs) const
  {
    if (__isset.field_terminator != rhs.__isset.field_terminator)
      return false;
    else if (__isset.field_terminator && !(field_terminator == rhs.field_terminator))
      return false;
    if (__isset.line_terminator != rhs.__isset.line_terminator)
      return false;
    else if (__isset.line_terminator && !(line_terminator == rhs.line_terminator))
      return false;
    if (__isset.escaped_by != rhs.__isset.escaped_by)
      return false;
    else if (__isset.escaped_by && !(escaped_by == rhs.escaped_by))
      return false;
    return true;
  }
  bool operator != (const TTableRowFormat &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TTableRowFormat & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TTableRowFormat &a, TTableRowFormat &b);

typedef struct _THdfsCachingOp__isset {
  _THdfsCachingOp__isset() : cache_pool_name(false) {}
  bool cache_pool_name;
} _THdfsCachingOp__isset;

class THdfsCachingOp {
 public:

  static const char* ascii_fingerprint; // = "EB04A806CFFC9025AEE48CFFDC378A86";
  static const uint8_t binary_fingerprint[16]; // = {0xEB,0x04,0xA8,0x06,0xCF,0xFC,0x90,0x25,0xAE,0xE4,0x8C,0xFF,0xDC,0x37,0x8A,0x86};

  THdfsCachingOp() : set_cached(0), cache_pool_name() {
  }

  virtual ~THdfsCachingOp() throw() {}

  bool set_cached;
  std::string cache_pool_name;

  _THdfsCachingOp__isset __isset;

  void __set_set_cached(const bool val) {
    set_cached = val;
  }

  void __set_cache_pool_name(const std::string& val) {
    cache_pool_name = val;
    __isset.cache_pool_name = true;
  }

  bool operator == (const THdfsCachingOp & rhs) const
  {
    if (!(set_cached == rhs.set_cached))
      return false;
    if (__isset.cache_pool_name != rhs.__isset.cache_pool_name)
      return false;
    else if (__isset.cache_pool_name && !(cache_pool_name == rhs.cache_pool_name))
      return false;
    return true;
  }
  bool operator != (const THdfsCachingOp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THdfsCachingOp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(THdfsCachingOp &a, THdfsCachingOp &b);


class TAlterTableOrViewRenameParams {
 public:

  static const char* ascii_fingerprint; // = "A756D3DBE614FB13F70BF7F7B6EB3D73";
  static const uint8_t binary_fingerprint[16]; // = {0xA7,0x56,0xD3,0xDB,0xE6,0x14,0xFB,0x13,0xF7,0x0B,0xF7,0xF7,0xB6,0xEB,0x3D,0x73};

  TAlterTableOrViewRenameParams() {
  }

  virtual ~TAlterTableOrViewRenameParams() throw() {}

   ::impala::TTableName new_table_name;

  void __set_new_table_name(const  ::impala::TTableName& val) {
    new_table_name = val;
  }

  bool operator == (const TAlterTableOrViewRenameParams & rhs) const
  {
    if (!(new_table_name == rhs.new_table_name))
      return false;
    return true;
  }
  bool operator != (const TAlterTableOrViewRenameParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableOrViewRenameParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableOrViewRenameParams &a, TAlterTableOrViewRenameParams &b);


class TAlterTableAddReplaceColsParams {
 public:

  static const char* ascii_fingerprint; // = "F26C3D962481589B5CD6AD45922ABEB7";
  static const uint8_t binary_fingerprint[16]; // = {0xF2,0x6C,0x3D,0x96,0x24,0x81,0x58,0x9B,0x5C,0xD6,0xAD,0x45,0x92,0x2A,0xBE,0xB7};

  TAlterTableAddReplaceColsParams() : replace_existing_cols(0) {
  }

  virtual ~TAlterTableAddReplaceColsParams() throw() {}

  std::vector< ::impala::TColumn>  columns;
  bool replace_existing_cols;

  void __set_columns(const std::vector< ::impala::TColumn> & val) {
    columns = val;
  }

  void __set_replace_existing_cols(const bool val) {
    replace_existing_cols = val;
  }

  bool operator == (const TAlterTableAddReplaceColsParams & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (!(replace_existing_cols == rhs.replace_existing_cols))
      return false;
    return true;
  }
  bool operator != (const TAlterTableAddReplaceColsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableAddReplaceColsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableAddReplaceColsParams &a, TAlterTableAddReplaceColsParams &b);

typedef struct _TAlterTableAddPartitionParams__isset {
  _TAlterTableAddPartitionParams__isset() : location(false), cache_op(false) {}
  bool location;
  bool cache_op;
} _TAlterTableAddPartitionParams__isset;

class TAlterTableAddPartitionParams {
 public:

  static const char* ascii_fingerprint; // = "D7E9D7B551990F2B5294B570ABEC33BA";
  static const uint8_t binary_fingerprint[16]; // = {0xD7,0xE9,0xD7,0xB5,0x51,0x99,0x0F,0x2B,0x52,0x94,0xB5,0x70,0xAB,0xEC,0x33,0xBA};

  TAlterTableAddPartitionParams() : if_not_exists(0), location() {
  }

  virtual ~TAlterTableAddPartitionParams() throw() {}

  std::vector< ::impala::TPartitionKeyValue>  partition_spec;
  bool if_not_exists;
  std::string location;
  THdfsCachingOp cache_op;

  _TAlterTableAddPartitionParams__isset __isset;

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  void __set_cache_op(const THdfsCachingOp& val) {
    cache_op = val;
    __isset.cache_op = true;
  }

  bool operator == (const TAlterTableAddPartitionParams & rhs) const
  {
    if (!(partition_spec == rhs.partition_spec))
      return false;
    if (!(if_not_exists == rhs.if_not_exists))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.cache_op != rhs.__isset.cache_op)
      return false;
    else if (__isset.cache_op && !(cache_op == rhs.cache_op))
      return false;
    return true;
  }
  bool operator != (const TAlterTableAddPartitionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableAddPartitionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableAddPartitionParams &a, TAlterTableAddPartitionParams &b);


class TAlterTableDropColParams {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  TAlterTableDropColParams() : col_name() {
  }

  virtual ~TAlterTableDropColParams() throw() {}

  std::string col_name;

  void __set_col_name(const std::string& val) {
    col_name = val;
  }

  bool operator == (const TAlterTableDropColParams & rhs) const
  {
    if (!(col_name == rhs.col_name))
      return false;
    return true;
  }
  bool operator != (const TAlterTableDropColParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableDropColParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableDropColParams &a, TAlterTableDropColParams &b);


class TAlterTableDropPartitionParams {
 public:

  static const char* ascii_fingerprint; // = "6F92A0A7B206615BE32209BF2E6A7ED1";
  static const uint8_t binary_fingerprint[16]; // = {0x6F,0x92,0xA0,0xA7,0xB2,0x06,0x61,0x5B,0xE3,0x22,0x09,0xBF,0x2E,0x6A,0x7E,0xD1};

  TAlterTableDropPartitionParams() : if_exists(0) {
  }

  virtual ~TAlterTableDropPartitionParams() throw() {}

  std::vector< ::impala::TPartitionKeyValue>  partition_spec;
  bool if_exists;

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  bool operator == (const TAlterTableDropPartitionParams & rhs) const
  {
    if (!(partition_spec == rhs.partition_spec))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TAlterTableDropPartitionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableDropPartitionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableDropPartitionParams &a, TAlterTableDropPartitionParams &b);


class TAlterTableChangeColParams {
 public:

  static const char* ascii_fingerprint; // = "13855CD6373047CF286CD488EE852316";
  static const uint8_t binary_fingerprint[16]; // = {0x13,0x85,0x5C,0xD6,0x37,0x30,0x47,0xCF,0x28,0x6C,0xD4,0x88,0xEE,0x85,0x23,0x16};

  TAlterTableChangeColParams() : col_name() {
  }

  virtual ~TAlterTableChangeColParams() throw() {}

  std::string col_name;
   ::impala::TColumn new_col_def;

  void __set_col_name(const std::string& val) {
    col_name = val;
  }

  void __set_new_col_def(const  ::impala::TColumn& val) {
    new_col_def = val;
  }

  bool operator == (const TAlterTableChangeColParams & rhs) const
  {
    if (!(col_name == rhs.col_name))
      return false;
    if (!(new_col_def == rhs.new_col_def))
      return false;
    return true;
  }
  bool operator != (const TAlterTableChangeColParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableChangeColParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableChangeColParams &a, TAlterTableChangeColParams &b);

typedef struct _TAlterTableSetTblPropertiesParams__isset {
  _TAlterTableSetTblPropertiesParams__isset() : partition_spec(false) {}
  bool partition_spec;
} _TAlterTableSetTblPropertiesParams__isset;

class TAlterTableSetTblPropertiesParams {
 public:

  static const char* ascii_fingerprint; // = "324187CF219174CEA00215B2721538EF";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x41,0x87,0xCF,0x21,0x91,0x74,0xCE,0xA0,0x02,0x15,0xB2,0x72,0x15,0x38,0xEF};

  TAlterTableSetTblPropertiesParams() : target(( ::impala::TTablePropertyType::type)0) {
  }

  virtual ~TAlterTableSetTblPropertiesParams() throw() {}

   ::impala::TTablePropertyType::type target;
  std::map<std::string, std::string>  properties;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TAlterTableSetTblPropertiesParams__isset __isset;

  void __set_target(const  ::impala::TTablePropertyType::type val) {
    target = val;
  }

  void __set_properties(const std::map<std::string, std::string> & val) {
    properties = val;
  }

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TAlterTableSetTblPropertiesParams & rhs) const
  {
    if (!(target == rhs.target))
      return false;
    if (!(properties == rhs.properties))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TAlterTableSetTblPropertiesParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableSetTblPropertiesParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableSetTblPropertiesParams &a, TAlterTableSetTblPropertiesParams &b);

typedef struct _TAlterTableSetFileFormatParams__isset {
  _TAlterTableSetFileFormatParams__isset() : partition_spec(false) {}
  bool partition_spec;
} _TAlterTableSetFileFormatParams__isset;

class TAlterTableSetFileFormatParams {
 public:

  static const char* ascii_fingerprint; // = "101E22EEE714785E462FCF6056B14937";
  static const uint8_t binary_fingerprint[16]; // = {0x10,0x1E,0x22,0xEE,0xE7,0x14,0x78,0x5E,0x46,0x2F,0xCF,0x60,0x56,0xB1,0x49,0x37};

  TAlterTableSetFileFormatParams() : file_format(( ::impala::THdfsFileFormat::type)0) {
  }

  virtual ~TAlterTableSetFileFormatParams() throw() {}

   ::impala::THdfsFileFormat::type file_format;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TAlterTableSetFileFormatParams__isset __isset;

  void __set_file_format(const  ::impala::THdfsFileFormat::type val) {
    file_format = val;
  }

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TAlterTableSetFileFormatParams & rhs) const
  {
    if (!(file_format == rhs.file_format))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TAlterTableSetFileFormatParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableSetFileFormatParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableSetFileFormatParams &a, TAlterTableSetFileFormatParams &b);

typedef struct _TAlterTableSetLocationParams__isset {
  _TAlterTableSetLocationParams__isset() : partition_spec(false) {}
  bool partition_spec;
} _TAlterTableSetLocationParams__isset;

class TAlterTableSetLocationParams {
 public:

  static const char* ascii_fingerprint; // = "620BD7B2710FAEABD876BE1FA48F69F0";
  static const uint8_t binary_fingerprint[16]; // = {0x62,0x0B,0xD7,0xB2,0x71,0x0F,0xAE,0xAB,0xD8,0x76,0xBE,0x1F,0xA4,0x8F,0x69,0xF0};

  TAlterTableSetLocationParams() : location() {
  }

  virtual ~TAlterTableSetLocationParams() throw() {}

  std::string location;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TAlterTableSetLocationParams__isset __isset;

  void __set_location(const std::string& val) {
    location = val;
  }

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TAlterTableSetLocationParams & rhs) const
  {
    if (!(location == rhs.location))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TAlterTableSetLocationParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableSetLocationParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableSetLocationParams &a, TAlterTableSetLocationParams &b);

typedef struct _TAlterTableUpdateStatsParams__isset {
  _TAlterTableUpdateStatsParams__isset() : table_stats(false), partition_stats(false), column_stats(false) {}
  bool table_stats;
  bool partition_stats;
  bool column_stats;
} _TAlterTableUpdateStatsParams__isset;

class TAlterTableUpdateStatsParams {
 public:

  static const char* ascii_fingerprint; // = "94B86B0A8A960A2EE444231943B9B8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x94,0xB8,0x6B,0x0A,0x8A,0x96,0x0A,0x2E,0xE4,0x44,0x23,0x19,0x43,0xB9,0xB8,0xDE};

  TAlterTableUpdateStatsParams() {
  }

  virtual ~TAlterTableUpdateStatsParams() throw() {}

   ::impala::TTableName table_name;
   ::impala::TTableStats table_stats;
  std::map<std::vector<std::string> ,  ::impala::TTableStats>  partition_stats;
  std::map<std::string,  ::impala::TColumnStats>  column_stats;

  _TAlterTableUpdateStatsParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_table_stats(const  ::impala::TTableStats& val) {
    table_stats = val;
    __isset.table_stats = true;
  }

  void __set_partition_stats(const std::map<std::vector<std::string> ,  ::impala::TTableStats> & val) {
    partition_stats = val;
    __isset.partition_stats = true;
  }

  void __set_column_stats(const std::map<std::string,  ::impala::TColumnStats> & val) {
    column_stats = val;
    __isset.column_stats = true;
  }

  bool operator == (const TAlterTableUpdateStatsParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.table_stats != rhs.__isset.table_stats)
      return false;
    else if (__isset.table_stats && !(table_stats == rhs.table_stats))
      return false;
    if (__isset.partition_stats != rhs.__isset.partition_stats)
      return false;
    else if (__isset.partition_stats && !(partition_stats == rhs.partition_stats))
      return false;
    if (__isset.column_stats != rhs.__isset.column_stats)
      return false;
    else if (__isset.column_stats && !(column_stats == rhs.column_stats))
      return false;
    return true;
  }
  bool operator != (const TAlterTableUpdateStatsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableUpdateStatsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableUpdateStatsParams &a, TAlterTableUpdateStatsParams &b);

typedef struct _TAlterTableSetCachedParams__isset {
  _TAlterTableSetCachedParams__isset() : partition_spec(false) {}
  bool partition_spec;
} _TAlterTableSetCachedParams__isset;

class TAlterTableSetCachedParams {
 public:

  static const char* ascii_fingerprint; // = "D53C33BA404147F976A44E46FA6C9A3D";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0x3C,0x33,0xBA,0x40,0x41,0x47,0xF9,0x76,0xA4,0x4E,0x46,0xFA,0x6C,0x9A,0x3D};

  TAlterTableSetCachedParams() {
  }

  virtual ~TAlterTableSetCachedParams() throw() {}

  THdfsCachingOp cache_op;
  std::vector< ::impala::TPartitionKeyValue>  partition_spec;

  _TAlterTableSetCachedParams__isset __isset;

  void __set_cache_op(const THdfsCachingOp& val) {
    cache_op = val;
  }

  void __set_partition_spec(const std::vector< ::impala::TPartitionKeyValue> & val) {
    partition_spec = val;
    __isset.partition_spec = true;
  }

  bool operator == (const TAlterTableSetCachedParams & rhs) const
  {
    if (!(cache_op == rhs.cache_op))
      return false;
    if (__isset.partition_spec != rhs.__isset.partition_spec)
      return false;
    else if (__isset.partition_spec && !(partition_spec == rhs.partition_spec))
      return false;
    return true;
  }
  bool operator != (const TAlterTableSetCachedParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableSetCachedParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableSetCachedParams &a, TAlterTableSetCachedParams &b);

typedef struct _TAlterTableParams__isset {
  _TAlterTableParams__isset() : rename_params(false), add_replace_cols_params(false), add_partition_params(false), change_col_params(false), drop_col_params(false), drop_partition_params(false), set_file_format_params(false), set_location_params(false), set_tbl_properties_params(false), update_stats_params(false), set_cached_params(false) {}
  bool rename_params;
  bool add_replace_cols_params;
  bool add_partition_params;
  bool change_col_params;
  bool drop_col_params;
  bool drop_partition_params;
  bool set_file_format_params;
  bool set_location_params;
  bool set_tbl_properties_params;
  bool update_stats_params;
  bool set_cached_params;
} _TAlterTableParams__isset;

class TAlterTableParams {
 public:

  static const char* ascii_fingerprint; // = "580708B432BEDEAF5C11FD9E24751E98";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x07,0x08,0xB4,0x32,0xBE,0xDE,0xAF,0x5C,0x11,0xFD,0x9E,0x24,0x75,0x1E,0x98};

  TAlterTableParams() : alter_type((TAlterTableType::type)0) {
  }

  virtual ~TAlterTableParams() throw() {}

  TAlterTableType::type alter_type;
   ::impala::TTableName table_name;
  TAlterTableOrViewRenameParams rename_params;
  TAlterTableAddReplaceColsParams add_replace_cols_params;
  TAlterTableAddPartitionParams add_partition_params;
  TAlterTableChangeColParams change_col_params;
  TAlterTableDropColParams drop_col_params;
  TAlterTableDropPartitionParams drop_partition_params;
  TAlterTableSetFileFormatParams set_file_format_params;
  TAlterTableSetLocationParams set_location_params;
  TAlterTableSetTblPropertiesParams set_tbl_properties_params;
  TAlterTableUpdateStatsParams update_stats_params;
  TAlterTableSetCachedParams set_cached_params;

  _TAlterTableParams__isset __isset;

  void __set_alter_type(const TAlterTableType::type val) {
    alter_type = val;
  }

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_rename_params(const TAlterTableOrViewRenameParams& val) {
    rename_params = val;
    __isset.rename_params = true;
  }

  void __set_add_replace_cols_params(const TAlterTableAddReplaceColsParams& val) {
    add_replace_cols_params = val;
    __isset.add_replace_cols_params = true;
  }

  void __set_add_partition_params(const TAlterTableAddPartitionParams& val) {
    add_partition_params = val;
    __isset.add_partition_params = true;
  }

  void __set_change_col_params(const TAlterTableChangeColParams& val) {
    change_col_params = val;
    __isset.change_col_params = true;
  }

  void __set_drop_col_params(const TAlterTableDropColParams& val) {
    drop_col_params = val;
    __isset.drop_col_params = true;
  }

  void __set_drop_partition_params(const TAlterTableDropPartitionParams& val) {
    drop_partition_params = val;
    __isset.drop_partition_params = true;
  }

  void __set_set_file_format_params(const TAlterTableSetFileFormatParams& val) {
    set_file_format_params = val;
    __isset.set_file_format_params = true;
  }

  void __set_set_location_params(const TAlterTableSetLocationParams& val) {
    set_location_params = val;
    __isset.set_location_params = true;
  }

  void __set_set_tbl_properties_params(const TAlterTableSetTblPropertiesParams& val) {
    set_tbl_properties_params = val;
    __isset.set_tbl_properties_params = true;
  }

  void __set_update_stats_params(const TAlterTableUpdateStatsParams& val) {
    update_stats_params = val;
    __isset.update_stats_params = true;
  }

  void __set_set_cached_params(const TAlterTableSetCachedParams& val) {
    set_cached_params = val;
    __isset.set_cached_params = true;
  }

  bool operator == (const TAlterTableParams & rhs) const
  {
    if (!(alter_type == rhs.alter_type))
      return false;
    if (!(table_name == rhs.table_name))
      return false;
    if (__isset.rename_params != rhs.__isset.rename_params)
      return false;
    else if (__isset.rename_params && !(rename_params == rhs.rename_params))
      return false;
    if (__isset.add_replace_cols_params != rhs.__isset.add_replace_cols_params)
      return false;
    else if (__isset.add_replace_cols_params && !(add_replace_cols_params == rhs.add_replace_cols_params))
      return false;
    if (__isset.add_partition_params != rhs.__isset.add_partition_params)
      return false;
    else if (__isset.add_partition_params && !(add_partition_params == rhs.add_partition_params))
      return false;
    if (__isset.change_col_params != rhs.__isset.change_col_params)
      return false;
    else if (__isset.change_col_params && !(change_col_params == rhs.change_col_params))
      return false;
    if (__isset.drop_col_params != rhs.__isset.drop_col_params)
      return false;
    else if (__isset.drop_col_params && !(drop_col_params == rhs.drop_col_params))
      return false;
    if (__isset.drop_partition_params != rhs.__isset.drop_partition_params)
      return false;
    else if (__isset.drop_partition_params && !(drop_partition_params == rhs.drop_partition_params))
      return false;
    if (__isset.set_file_format_params != rhs.__isset.set_file_format_params)
      return false;
    else if (__isset.set_file_format_params && !(set_file_format_params == rhs.set_file_format_params))
      return false;
    if (__isset.set_location_params != rhs.__isset.set_location_params)
      return false;
    else if (__isset.set_location_params && !(set_location_params == rhs.set_location_params))
      return false;
    if (__isset.set_tbl_properties_params != rhs.__isset.set_tbl_properties_params)
      return false;
    else if (__isset.set_tbl_properties_params && !(set_tbl_properties_params == rhs.set_tbl_properties_params))
      return false;
    if (__isset.update_stats_params != rhs.__isset.update_stats_params)
      return false;
    else if (__isset.update_stats_params && !(update_stats_params == rhs.update_stats_params))
      return false;
    if (__isset.set_cached_params != rhs.__isset.set_cached_params)
      return false;
    else if (__isset.set_cached_params && !(set_cached_params == rhs.set_cached_params))
      return false;
    return true;
  }
  bool operator != (const TAlterTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TAlterTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TAlterTableParams &a, TAlterTableParams &b);

typedef struct _TCreateTableLikeParams__isset {
  _TCreateTableLikeParams__isset() : file_format(false), comment(false), location(false) {}
  bool file_format;
  bool comment;
  bool location;
} _TCreateTableLikeParams__isset;

class TCreateTableLikeParams {
 public:

  static const char* ascii_fingerprint; // = "7BEC16F01713BB030792212D7EDE7C30";
  static const uint8_t binary_fingerprint[16]; // = {0x7B,0xEC,0x16,0xF0,0x17,0x13,0xBB,0x03,0x07,0x92,0x21,0x2D,0x7E,0xDE,0x7C,0x30};

  TCreateTableLikeParams() : is_external(0), if_not_exists(0), owner(), file_format(( ::impala::THdfsFileFormat::type)0), comment(), location() {
  }

  virtual ~TCreateTableLikeParams() throw() {}

   ::impala::TTableName table_name;
   ::impala::TTableName src_table_name;
  bool is_external;
  bool if_not_exists;
  std::string owner;
   ::impala::THdfsFileFormat::type file_format;
  std::string comment;
  std::string location;

  _TCreateTableLikeParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_src_table_name(const  ::impala::TTableName& val) {
    src_table_name = val;
  }

  void __set_is_external(const bool val) {
    is_external = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_file_format(const  ::impala::THdfsFileFormat::type val) {
    file_format = val;
    __isset.file_format = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  bool operator == (const TCreateTableLikeParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(src_table_name == rhs.src_table_name))
      return false;
    if (!(is_external == rhs.is_external))
      return false;
    if (!(if_not_exists == rhs.if_not_exists))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (__isset.file_format != rhs.__isset.file_format)
      return false;
    else if (__isset.file_format && !(file_format == rhs.file_format))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    return true;
  }
  bool operator != (const TCreateTableLikeParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTableLikeParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateTableLikeParams &a, TCreateTableLikeParams &b);

typedef struct _TCreateTableParams__isset {
  _TCreateTableParams__isset() : partition_columns(false), row_format(false), comment(false), location(false), table_properties(false), serde_properties(false), cache_op(false) {}
  bool partition_columns;
  bool row_format;
  bool comment;
  bool location;
  bool table_properties;
  bool serde_properties;
  bool cache_op;
} _TCreateTableParams__isset;

class TCreateTableParams {
 public:

  static const char* ascii_fingerprint; // = "53D02A5A9E50874DA7FDEA7420DB4D57";
  static const uint8_t binary_fingerprint[16]; // = {0x53,0xD0,0x2A,0x5A,0x9E,0x50,0x87,0x4D,0xA7,0xFD,0xEA,0x74,0x20,0xDB,0x4D,0x57};

  TCreateTableParams() : file_format(( ::impala::THdfsFileFormat::type)0), is_external(0), if_not_exists(0), owner(), comment(), location() {
  }

  virtual ~TCreateTableParams() throw() {}

   ::impala::TTableName table_name;
  std::vector< ::impala::TColumn>  columns;
  std::vector< ::impala::TColumn>  partition_columns;
   ::impala::THdfsFileFormat::type file_format;
  bool is_external;
  bool if_not_exists;
  std::string owner;
  TTableRowFormat row_format;
  std::string comment;
  std::string location;
  std::map<std::string, std::string>  table_properties;
  std::map<std::string, std::string>  serde_properties;
  THdfsCachingOp cache_op;

  _TCreateTableParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_columns(const std::vector< ::impala::TColumn> & val) {
    columns = val;
  }

  void __set_partition_columns(const std::vector< ::impala::TColumn> & val) {
    partition_columns = val;
    __isset.partition_columns = true;
  }

  void __set_file_format(const  ::impala::THdfsFileFormat::type val) {
    file_format = val;
  }

  void __set_is_external(const bool val) {
    is_external = val;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_row_format(const TTableRowFormat& val) {
    row_format = val;
    __isset.row_format = true;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_location(const std::string& val) {
    location = val;
    __isset.location = true;
  }

  void __set_table_properties(const std::map<std::string, std::string> & val) {
    table_properties = val;
    __isset.table_properties = true;
  }

  void __set_serde_properties(const std::map<std::string, std::string> & val) {
    serde_properties = val;
    __isset.serde_properties = true;
  }

  void __set_cache_op(const THdfsCachingOp& val) {
    cache_op = val;
    __isset.cache_op = true;
  }

  bool operator == (const TCreateTableParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (__isset.partition_columns != rhs.__isset.partition_columns)
      return false;
    else if (__isset.partition_columns && !(partition_columns == rhs.partition_columns))
      return false;
    if (!(file_format == rhs.file_format))
      return false;
    if (!(is_external == rhs.is_external))
      return false;
    if (!(if_not_exists == rhs.if_not_exists))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (__isset.row_format != rhs.__isset.row_format)
      return false;
    else if (__isset.row_format && !(row_format == rhs.row_format))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.location != rhs.__isset.location)
      return false;
    else if (__isset.location && !(location == rhs.location))
      return false;
    if (__isset.table_properties != rhs.__isset.table_properties)
      return false;
    else if (__isset.table_properties && !(table_properties == rhs.table_properties))
      return false;
    if (__isset.serde_properties != rhs.__isset.serde_properties)
      return false;
    else if (__isset.serde_properties && !(serde_properties == rhs.serde_properties))
      return false;
    if (__isset.cache_op != rhs.__isset.cache_op)
      return false;
    else if (__isset.cache_op && !(cache_op == rhs.cache_op))
      return false;
    return true;
  }
  bool operator != (const TCreateTableParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateTableParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateTableParams &a, TCreateTableParams &b);

typedef struct _TCreateOrAlterViewParams__isset {
  _TCreateOrAlterViewParams__isset() : comment(false), if_not_exists(false) {}
  bool comment;
  bool if_not_exists;
} _TCreateOrAlterViewParams__isset;

class TCreateOrAlterViewParams {
 public:

  static const char* ascii_fingerprint; // = "98202B8FE0A5E9F9307497EC57055DA9";
  static const uint8_t binary_fingerprint[16]; // = {0x98,0x20,0x2B,0x8F,0xE0,0xA5,0xE9,0xF9,0x30,0x74,0x97,0xEC,0x57,0x05,0x5D,0xA9};

  TCreateOrAlterViewParams() : owner(), original_view_def(), expanded_view_def(), comment(), if_not_exists(0) {
  }

  virtual ~TCreateOrAlterViewParams() throw() {}

   ::impala::TTableName view_name;
  std::vector< ::impala::TColumn>  columns;
  std::string owner;
  std::string original_view_def;
  std::string expanded_view_def;
  std::string comment;
  bool if_not_exists;

  _TCreateOrAlterViewParams__isset __isset;

  void __set_view_name(const  ::impala::TTableName& val) {
    view_name = val;
  }

  void __set_columns(const std::vector< ::impala::TColumn> & val) {
    columns = val;
  }

  void __set_owner(const std::string& val) {
    owner = val;
  }

  void __set_original_view_def(const std::string& val) {
    original_view_def = val;
  }

  void __set_expanded_view_def(const std::string& val) {
    expanded_view_def = val;
  }

  void __set_comment(const std::string& val) {
    comment = val;
    __isset.comment = true;
  }

  void __set_if_not_exists(const bool val) {
    if_not_exists = val;
    __isset.if_not_exists = true;
  }

  bool operator == (const TCreateOrAlterViewParams & rhs) const
  {
    if (!(view_name == rhs.view_name))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(owner == rhs.owner))
      return false;
    if (!(original_view_def == rhs.original_view_def))
      return false;
    if (!(expanded_view_def == rhs.expanded_view_def))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.if_not_exists != rhs.__isset.if_not_exists)
      return false;
    else if (__isset.if_not_exists && !(if_not_exists == rhs.if_not_exists))
      return false;
    return true;
  }
  bool operator != (const TCreateOrAlterViewParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TCreateOrAlterViewParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TCreateOrAlterViewParams &a, TCreateOrAlterViewParams &b);

typedef struct _TComputeStatsParams__isset {
  _TComputeStatsParams__isset() : col_stats_query(false) {}
  bool col_stats_query;
} _TComputeStatsParams__isset;

class TComputeStatsParams {
 public:

  static const char* ascii_fingerprint; // = "C27040E48FCE127FC0BCE9C2448AA07C";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0x70,0x40,0xE4,0x8F,0xCE,0x12,0x7F,0xC0,0xBC,0xE9,0xC2,0x44,0x8A,0xA0,0x7C};

  TComputeStatsParams() : tbl_stats_query(), col_stats_query() {
  }

  virtual ~TComputeStatsParams() throw() {}

   ::impala::TTableName table_name;
  std::string tbl_stats_query;
  std::string col_stats_query;

  _TComputeStatsParams__isset __isset;

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_tbl_stats_query(const std::string& val) {
    tbl_stats_query = val;
  }

  void __set_col_stats_query(const std::string& val) {
    col_stats_query = val;
    __isset.col_stats_query = true;
  }

  bool operator == (const TComputeStatsParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(tbl_stats_query == rhs.tbl_stats_query))
      return false;
    if (__isset.col_stats_query != rhs.__isset.col_stats_query)
      return false;
    else if (__isset.col_stats_query && !(col_stats_query == rhs.col_stats_query))
      return false;
    return true;
  }
  bool operator != (const TComputeStatsParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TComputeStatsParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TComputeStatsParams &a, TComputeStatsParams &b);


class TDropDbParams {
 public:

  static const char* ascii_fingerprint; // = "7D61C9AA00102AB4D8F72A1DA58297DC";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x61,0xC9,0xAA,0x00,0x10,0x2A,0xB4,0xD8,0xF7,0x2A,0x1D,0xA5,0x82,0x97,0xDC};

  TDropDbParams() : db(), if_exists(0) {
  }

  virtual ~TDropDbParams() throw() {}

  std::string db;
  bool if_exists;

  void __set_db(const std::string& val) {
    db = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  bool operator == (const TDropDbParams & rhs) const
  {
    if (!(db == rhs.db))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TDropDbParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropDbParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropDbParams &a, TDropDbParams &b);


class TDropTableOrViewParams {
 public:

  static const char* ascii_fingerprint; // = "790158CF902C527D004C99E60A2E4B2E";
  static const uint8_t binary_fingerprint[16]; // = {0x79,0x01,0x58,0xCF,0x90,0x2C,0x52,0x7D,0x00,0x4C,0x99,0xE6,0x0A,0x2E,0x4B,0x2E};

  TDropTableOrViewParams() : if_exists(0) {
  }

  virtual ~TDropTableOrViewParams() throw() {}

   ::impala::TTableName table_name;
  bool if_exists;

  void __set_table_name(const  ::impala::TTableName& val) {
    table_name = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  bool operator == (const TDropTableOrViewParams & rhs) const
  {
    if (!(table_name == rhs.table_name))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    return true;
  }
  bool operator != (const TDropTableOrViewParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropTableOrViewParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropTableOrViewParams &a, TDropTableOrViewParams &b);

typedef struct _TDropFunctionParams__isset {
  _TDropFunctionParams__isset() : signature(false) {}
  bool signature;
} _TDropFunctionParams__isset;

class TDropFunctionParams {
 public:

  static const char* ascii_fingerprint; // = "912BD3CCA9A9785F7885C5D0427E38E4";
  static const uint8_t binary_fingerprint[16]; // = {0x91,0x2B,0xD3,0xCC,0xA9,0xA9,0x78,0x5F,0x78,0x85,0xC5,0xD0,0x42,0x7E,0x38,0xE4};

  TDropFunctionParams() : if_exists(0), signature() {
  }

  virtual ~TDropFunctionParams() throw() {}

   ::impala::TFunctionName fn_name;
  std::vector< ::impala::TColumnType>  arg_types;
  bool if_exists;
  std::string signature;

  _TDropFunctionParams__isset __isset;

  void __set_fn_name(const  ::impala::TFunctionName& val) {
    fn_name = val;
  }

  void __set_arg_types(const std::vector< ::impala::TColumnType> & val) {
    arg_types = val;
  }

  void __set_if_exists(const bool val) {
    if_exists = val;
  }

  void __set_signature(const std::string& val) {
    signature = val;
    __isset.signature = true;
  }

  bool operator == (const TDropFunctionParams & rhs) const
  {
    if (!(fn_name == rhs.fn_name))
      return false;
    if (!(arg_types == rhs.arg_types))
      return false;
    if (!(if_exists == rhs.if_exists))
      return false;
    if (__isset.signature != rhs.__isset.signature)
      return false;
    else if (__isset.signature && !(signature == rhs.signature))
      return false;
    return true;
  }
  bool operator != (const TDropFunctionParams &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TDropFunctionParams & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TDropFunctionParams &a, TDropFunctionParams &b);

} // namespace

#endif
